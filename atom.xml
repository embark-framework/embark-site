<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Embark</title>
  
  <subtitle>The all-in-one developer platform for building and deploying decentralized applications.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://embark.status.im/"/>
  <updated>2019-05-07T08:18:52.676Z</updated>
  <id>https://embark.status.im/</id>
  
  <author>
    <name>Embark</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introducing Embark 4.0 - Cockpit, Debugger and more</title>
    <link href="https://embark.status.im/news/2019/03/19/introducing-embark-4/"/>
    <id>https://embark.status.im/news/2019/03/19/introducing-embark-4/</id>
    <published>2019-03-19T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/images/EMBARK_HEADER_ALT_OPTIMIZED.jpg" alt="Embark" title="Embark"></p><p><strong>Embark 4.0 is officially out of beta and ready for developers around the world. Cockpit (the new web UI dashboard), a robust debugger, and the frontend-agnostic build pipeline provide the support you need to develop production-ready decentralized applications.</strong></p><p>2019 is off to a great start! We’ve been taking Embark 4.0 from alpha to beta, and are now happy to present the official release of version 4.0. It comes jam-packed with many new features, including Cockpit, a transaction debugger, and a massively improved integration with existing frontend tooling. To mark this major milestone, we’ve also launched our new website with updated docs, more tutorials, and a brand new look!</p><p>Thanks to all the developers who have been using, testing, contributing to, and providing feedback on the beta version. The official release of 4.0 is now ready for the world to use. Read on for an overview of the key features or simply get going with our <a href="/docs/quick_start.html">Quick Start Guide</a>.</p><div class="c-notification c-notification--info">  <p><strong>Embark now follows SemVer</strong></p>  <p></p><p>Version 4.0 contains <strong>some breaking changes</strong>, however we kept them at a minimum and you can learn about all of them in our article on <a href="/news/2019/03/18/upgrading-to-embark-4/">upgrading DApps created with Embark 3.x</a>.</p><p>That said, with the release of 4.0 <strong>Embark will now follow SemVer</strong> making it easier for developers to update and watch out for changes.</p><p></p></div> <h2 id="Cockpit-–-An-intuitive-Web-Interface"><a href="#Cockpit-–-An-intuitive-Web-Interface" class="headerlink" title="Cockpit – An intuitive Web Interface"></a>Cockpit – An intuitive Web Interface</h2><p>Cockpit has been under active development for a few months and is officially ready! Cockpit is your command center for building, debugging, and deploying decentralized applications.</p><p><strong>The dashboard</strong> is the first page users see when they load Cockpit. It provides an overview of all processes controlled by Embark and comes with an interactive console and predictive commands, allowing developers to conveniently interact with Embark and all components (e.g. Ethereum blockchain, ENS, Whisper, IPFS/Swarm, etc). The dashboard also  displays a summary of deployed contracts and enables users to search for accounts, blocks, addresses, and transactions.</p><p>For more information regarding Cockpit’s dashboard, please refer to the <a href="/docs/cockpit_dashboard.html">Embark docs</a>.</p><p><img src="/assets/images/cockpit_dashboard_release.png" alt="Cockpit Dashboard" title="Cockpit Dashboard"></p><p><strong>The blockchain explorer</strong> provides detailed views of blocks, transactions, smart contracts, and connected accounts. We’ve also introduced a brand new way to analyze deployed instances of smart contracts. Within the contracts view, users can interact with a contract’s API, view the ABI and bytecode, retrieve the contract’s transaction logs, and invoke Cockpit’s new integrated debugger. <a href="/docs/cockpit_explorer.html">Learn more</a></p><p><img src="/assets/images/cockpit_explorer_overview.png" alt="Cockpit Explorer" title="Cockpit Explorer"></p><p><strong>Iterative Deployment</strong> enables selective deployment of smart contracts to any network, removing headaches when it comes to complex applications. Using the deployment panel, single or multiple smart contracts can be deployed to production safely, with full control over the process. <a href="/docs/cockpit_deployment.html">Learn more</a></p><p><strong>The code editor</strong> allows you to edit a DApp’s source files from within Cockpit for quick and easy updates. The web-based editor enables a DApp’s source code to be changed on the fly. Like any typical code editor, it has a file tree, can open multiple source files, and allows files to be added and deleted. Users can also access and interact with contact properties and methods in the editor’s UI. Contracts even get redeployed as changes are saved – iterative development at its best! <a href="/docs/cockpit_editor.html">Learn more</a></p><p><img src="/assets/images/cockpit_editor_release.png" alt="Cockpit Editor" title="Cockpit Editor"></p><h2 id="Integrated-Debugger"><a href="#Integrated-Debugger" class="headerlink" title="Integrated Debugger"></a>Integrated Debugger</h2><p>Debugging is an important part of all software development and has been a significant challenge for blockchain developers for some time. The new Embark debugger provides an easy way to debug contracts by displaying solidity source codes lines where a transaction failed. This greatly speeds up development and helps to eliminate bugs.</p><p>The debugger comes in handy in a number of situations. For example, if a transaction fails, no problem! The debugger will spring into action and offer a quick shortcut to help identify the problem and start troubleshooting.</p><h2 id="Better-tooling-integration"><a href="#Better-tooling-integration" class="headerlink" title="Better tooling integration"></a>Better tooling integration</h2><p>Embark is now compatible with any frontend tooling such as Create React App and the CLI tools for Angular, Vue, and more.</p><p>Previously, Embark used its own pipeline, which was compatible with most frontend frameworks by way of Webpack configuration. However, it wasn’t compatible with most frontend tooling. Embark 4 is now fully frontend-agnostic, but the old pipeline is still available if you wish to use it.</p><h2 id="Additional-Updates-and-Features"><a href="#Additional-Updates-and-Features" class="headerlink" title="Additional Updates and Features"></a>Additional Updates and Features</h2><p>We’ve introduced a number of updates and new features to go along with the key features mentioned above. These include:</p><ul><li><strong>New contract deployment hooks</strong>: onDeploy and afterDeploy allow for complete customization of the deployment lifecycle.</li><li><strong>Better account configuration</strong>: accounts are now consistently defined in config/blockchain.js.</li><li><strong>Embark can be installed as a local dependency for per-project versioning</strong>: global installation of Embark is no longer required.</li></ul><h2 id="A-new-Website-and-Fresh-New-Look"><a href="#A-new-Website-and-Fresh-New-Look" class="headerlink" title="A new Website and Fresh New Look"></a>A new Website and Fresh New Look</h2><p><img src="/assets/images/website_release.png" alt="Website Release" title="Website Release"></p><p>Embarking into decentralized applications is exciting and fun. That’s precisely why we updated our website: to better accompany developers on their journey. Not only did we give Embark a facelift with slick new illustrations and a fresh logo, but we also made it easier to navigate developer resources such as docs, plugins, and tutorials. For developers new to Embark, the  Quick Start guide will get you up and running in no time!</p><h2 id="Get-Started-Now"><a href="#Get-Started-Now" class="headerlink" title="Get Started Now"></a>Get Started Now</h2><p>Embark 4.0 is a great companion for those embarking into the ether! From brand new developers still learning the concepts, to seasoned pros with a specific project in mind, Embark is the ideal all-in-one development platform for building and deploying decentralized applications. Whether developing DApps end-to-end or simply deploying smart contracts, Embark allows developers to pick and choose which features, plugins, and tools to integrate.</p><p>Check out the <a href="/docs/quick_start.html">Quick Start guide</a> or dive right into the <a href="/docs">documentation</a>.</p><p>Chat with us in <a href="https://gitter.im/embark-framework/Lobby" target="_blank" rel="noopener">Gitter</a><br>Star the repo on <a href="https://github.com/embark-framework/embark" target="_blank" rel="noopener">GitHub</a><br>Follow us on <a href="https://twitter.com/EmbarkProject" target="_blank" rel="noopener">Twitter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/images/EMBARK_HEADER_ALT_OPTIMIZED.jpg&quot; alt=&quot;Embark&quot; title=&quot;Embark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Embark 4.0 is officially out of bet
      
    
    </summary>
    
      <category term="announcements" scheme="https://embark.status.im/categories/announcements/"/>
    
    
  </entry>
  
  <entry>
    <title>How to upgrade to Embark 4</title>
    <link href="https://embark.status.im/news/2019/03/18/upgrading-to-embark-4/"/>
    <id>https://embark.status.im/news/2019/03/18/upgrading-to-embark-4/</id>
    <published>2019-03-18T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.676Z</updated>
    
    <content type="html"><![CDATA[<p>The release of Embark 4.0 is close at hand and the release candidate, <code>beta.1</code>, will introduce some breaking changes. Let’s see what it takes to update an Embark 3.x Dapp to Embark 4.</p><h2 id="Use-any-frontend-build-tool"><a href="#Use-any-frontend-build-tool" class="headerlink" title="Use any frontend build tool!"></a>Use <strong>any</strong> frontend build tool!</h2><p>That’s right! The use of Embark’s builtin pipeline in no longer required.</p><p>Historically, Embark 3.x came with a special Webpack pipeline because it automated development tasks, such as enabling the use of “magic” imports (ie <code>import SimpleStorage from &quot;Embark/contracts/SimpleStorage&quot;;</code> or <code>import EmbarkJS from Embark/EmbarkJS</code>), and establishing a Web3 connection for the Dapp.</p><p>However, we discovered the hard way that those advantages were not worth the hit in development efficiency, compared to using an optimized pipeline, such as <code>create-react-app</code> or Angular CLI. Indeed, on every save, Embark would regenerate a lot of the Dapp-side code and then webpack the entire Dapp, often taking quite some time.</p><p>Therefore, we are announcing that Embark 4 can use <strong>any</strong> frontend development build tooling, letting Embark handle the things that it does best. This means we can use tools such as <code>create-react-app</code> or Angular CLI, or pretty much any other tool of your choice, alongside Embark. The Embark 3.x pipeline is still available for use for quick start applications if needed.</p><p>To migrate an existing Embark 3.x Dapp over to use Embark 4 with a third party pipeline, there are few small changes to your Dapp that are needed.</p><div class="c-notification c-notification--info">  <p><strong>NOTE</strong></p>  <p></p><p>If you are not interested in using a third party pipeline, you can skip to the next section to <a href="#New-Web3-plugin">see the rest of the breaking changes needed to migrate a Dapp to Embark 4</a>.</p><p></p></div> <h3 id="Converting-to-another-pipeline"><a href="#Converting-to-another-pipeline" class="headerlink" title="Converting to another pipeline"></a>Converting to another pipeline</h3><p>Converting to a third party pipeline is easy. This can be done with three simple improvements that Embark 4 has made available for us.</p><h4 id="Artifact-generation-directory"><a href="#Artifact-generation-directory" class="headerlink" title="Artifact generation directory"></a>Artifact generation directory</h4><p>NOTE: If you are planning on using Embark’s built-in Webpack pipeline (and not use a third party pipeline), please <a href="#New-Web3-plugin">skip down to the remainder of the Embark 4 breaking changes</a>.</p><p>Embark 4 generates <a href="/docs/javascript_usage.html#Embark-Artifacts">Smart Contract artifacts</a> for all of the Smart Contract in your Dapp. These artifacts enable importing the Dapp’s Smart Contracts into the Dapp’s source code. Most of these artifacts were already generated before, but lived inside the <code>.embark/</code> folder. Since most modern frontend build systems require source files to live inside of a very specific source folder, we have given developers the opportunity to specify the destination folder for these artifacts, allowing the frontend build tool to pick them up for processing.</p><p>The first thing we need to do is add a new <code>generationDir</code> property in the root of <code>embark.json</code>. This property tells Embark where to place the generated artifacts in the Dapp’s filesystem. For example, <code>create-react-app</code> (CRA) has <code>src/</code> as source folder and the artifacts must be placed in that folder, so we would add in <code>embark.json</code>:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"generationDir"</span>: <span class="string">"src/embarkArtifacts"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="“Magic”-imports"><a href="#“Magic”-imports" class="headerlink" title="“Magic” imports"></a>“Magic” imports</h4><p>Afterwards, we need to convert all “magic” imports in our Dapp’s code to relative imports.</p><p>The first one is the EmbarkJS import. The “magic” import is <code>&quot;Embark/EmbarkJS&quot;</code>. Anywhere we have <code>&quot;Embark/EmbarkJS&quot;</code> in our Dapp’s code, we need to convert that to the relative path. Because we are trying to get the <code>EmbarkJS</code> library, and the <code>embarkjs.js</code> script is located in the root of  <code>embarkArtifacts/</code>, we need to replace</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> EmbarkJS <span class="keyword">from</span> <span class="string">"Embark/EmbarkJS"</span></span><br></pre></td></tr></table></figure><p>with<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> EmbarkJS <span class="keyword">from</span> <span class="string">"./embarkArtifacts/embarkjs"</span></span><br></pre></td></tr></table></figure></p><div class="c-notification c-notification--info">  <p><strong>NOTE</strong></p>  <p></p><p>NOTE: The relative path is dependent upon the generationDir setting specified in embark.json <a href="#Artifact-generation-directory">see the “Artifact generation directory” section above</a>.</p><p></p></div> <p>Secondly, we need to update the “magic” Smart Contract imports. These will need to change from</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ContractName <span class="keyword">from</span> <span class="string">"Embark/contract/ContractName"</span>;</span><br></pre></td></tr></table></figure><p>to<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ContractName <span class="keyword">from</span> <span class="string">"./embarkArtifacts/contracts/ContractName"</span>;</span><br></pre></td></tr></table></figure></p><p>Thirdly, there used to be <code>import web3 from &quot;Embark/web3&quot;</code>, but it has been removed in Embark 4 in favor of using a global Web3 object. Don’t worry, Embark is not removing web3 support, far from it. We actually just got rid of an import that did not provide a lot of benefit. In Embark 4, the global <code>web3</code> object is now available everywhere in the Dapp.</p><p>Now, all the Embark files and configs from your Dapp can be moved in to a project created by the frontend build tool of your choice.</p><h3 id="New-project-with-another-pipeline"><a href="#New-project-with-another-pipeline" class="headerlink" title="New project with another pipeline"></a>New project with another pipeline</h3><p>Starting a new Dapp from scratch is easy, we have two options.</p><h4 id="Embark’s-create-react-dapp-template"><a href="#Embark’s-create-react-dapp-template" class="headerlink" title="Embark’s create-react-dapp template"></a>Embark’s create-react-dapp template</h4><p>The easiest option is to use our <a href="https://github.com/embark-framework/embark-create-react-dapp-template" target="_blank" rel="noopener">new Embark CRA template</a>. It sets up a simple Embark project with all of the familiar files present in an Embark 3.x Dapp, with one minor difference: the config files are located in an <code>embarkConfig/</code> folder in the root of the Dapp to make sure they don’t clash with CRA’s config folder/files.</p><p>To get started with Embark’s CRA template,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">embark new --template embark-react-dapp my-dapp</span><br><span class="line">cd my-dapp</span><br><span class="line">embark run</span><br></pre></td></tr></table></figure><p>Then, in another terminal,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd my-dapp</span><br><span class="line">yarn start // or alternatively, npm run start</span><br></pre></td></tr></table></figure><p>That’s it!</p><h4 id="For-other-build-tools"><a href="#For-other-build-tools" class="headerlink" title="For other build tools"></a>For other build tools</h4><p>If we want to use another build tool than CRA, here are the steps:</p><p>Create a project using a frontend build tool like Angular CLI. Then, in another directory, execute <code>embark new your_projects_name</code>.</p><p>Afterwards, we copy all the files and folders from the Embark project to the build tool’s folder. The only tweak that you will need to do is go in <code>config/pipeline.js</code> and set <code>enabled: false</code>, so that Embark’s pipeline is disabled.</p><p>We can also go in <code>embark.json</code> and remove the <code>app</code> section (as well as Embark’s source dir that you will not be using).</p><p>Lastly, check out <a href="#Artifact-generation-directory">the “Artifact generation directory” section above</a> to make sure your artifacts directory is set up correctly for you build tool.</p><p>There you go, your project is ready.</p><p>We know that these steps are a bit too much, so we are working on a new command that lets you initialize an Embark project from inside a build tool’s directory. Keep an eye out for that.</p><h2 id="New-Web3-plugin"><a href="#New-Web3-plugin" class="headerlink" title="New Web3 plugin"></a>New Web3 plugin</h2><p>Starting with Embark 4 beta.1, Embark no longer supplies the Dapp with <code>Web3.js</code> by default. Don’t run. We did that so that we can now have the possibility of supporting more than just <code>Web3.js</code>, such as EthersJS, and more. You can even roll your own.</p><p>To continue using <code>Web3.js</code> inside the Embark 4 Dapp, execute the following command in the Embark console: <code>plugin install embarkjs-connector-web3</code>.</p><p>This simply <a href="https://embark.status.im/docs/installing_plugins.html">installs <code>embarkjs-connector-web3</code> as a plugin</a>. Alternatively, this plugin can be installed manually by executing:</p><ol><li><code>yarn add embarkjs-connector-web3</code> or <code>npm install --save embarkjs-connector-web3</code></li><li>Adding <code>&quot;embarkjs-connector-web3&quot;: {}</code> to the <code>plugins</code> section of <code>embark.json</code></li></ol><p>It’s as simple as that. This plugin will add the necessary commands and code for the Dapp to connect to the blockchain and register the necessary providers. The only prerequisite is for the Dapp to import <code>EmbarkJS</code> at least once. If using a third party pipeline, the <code>EmbarkJS</code> file can be imported using <code>import EmbarkJS from &quot;./embarkArtifacts/embarkjs.js&quot;</code> (or as specified by the <code>generationDir</code> in <code>embark.json</code>). If using Embark’s built-in pipeline, <code>EmbarkJS</code> can be imported using <code>import EmbarkJS from &quot;Embark/EmbarkJS&quot;;</code>.</p><h2 id="New-Blockchain-account-configs"><a href="#New-Blockchain-account-configs" class="headerlink" title="New Blockchain account configs"></a>New Blockchain account configs</h2><p>Embark 4 adds some new blockchain account configurations. To try to keep things as simple as possible, these additions are really similar to the ones in the contract configuration. For more information, please read the <a href="https://embark.status.im/docs/blockchain_accounts_configuration.html">Accounts Blockchain configuration guide</a> in our docs.</p><p>However, we did introduce some small breaking changes. We removed:</p><ul><li><code>account</code>: This is completely replaced by the new <code>accounts</code> property (notice the <code>s</code> at the end of <code>accounts</code>). It gives the developer more flexibility. To have exactly the same behavior as before, just use the <code>nodeAccounts</code> account type as <a href="https://embark.status.im/docs/blockchain_accounts_configuration.md#parameter-descriptions">described in the docs</a></li><li><code>simulatorMnemonic</code>: Removed in favor of Ganache’s default mnemonic. If this functionality is still needed, please specify the desired mnemonic in the <a href="https://embark.status.im/docs/blockchain_accounts_configuration.md#parameter-descriptions">blockchain config’s <code>mnemonic</code> account type</a>.</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This is a small taste of the features added to Embark 4, namely the ability to use a frontend build tool of choice. However, Embark 4 is jam-packed with additional new features, which we’ll detail during the Embark 4 release.</p><p>In the meantime, all the Embark 4 goodness doesn’t come at too high a price in terms of breaking changes.</p><p>Upgrading to Embark 4 will be a blast. If you ever have an issue, make sure to hit us up on <a href="https://gitter.im/embark-framework/Lobby" target="_blank" rel="noopener">Gitter</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The release of Embark 4.0 is close at hand and the release candidate, &lt;code&gt;beta.1&lt;/code&gt;, will introduce some breaking changes. Let’s se
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Building a decentralized Reddit with Embark - Part 3</title>
    <link href="https://embark.status.im/news/2019/02/18/building-a-decentralized-reddit-with-embark-part-3/"/>
    <id>https://embark.status.im/news/2019/02/18/building-a-decentralized-reddit-with-embark-part-3/</id>
    <published>2019-02-18T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.676Z</updated>
    
    <content type="html"><![CDATA[<p>Hopefully you’ve read <a href="/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/">the first</a> and <a href="/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2/">second part</a> of this tutorial on building a decentralized Reddit application using Embark. If not, we highly recommend you doing so, because in this part, we’ll be focussing on building the front-end for our application and continue where we’ve left off.</p><ul><li><a href="/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/"><strong>Part 1</strong> - Setting up the project and implementing a Smart Contract</a></li><li><a href="/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2/"><strong>Part 2</strong> - Testing the Smart Contract through EmbarkJS</a></li></ul><p>We’ll be using React as a client-side JavaScript library to build our application. However, we can use any framework of our choice, so feel free to follow along while using your favourite framework equivalents!</p><p><strong>The code for this tutorial can be found in <a href="https://github.com/embark-framework/dreddit-tutorial" target="_blank" rel="noopener">this repository</a></strong>.</p><h2 id="Rendering-our-first-component"><a href="#Rendering-our-first-component" class="headerlink" title="Rendering our first component"></a>Rendering our first component</h2><p>Alright, before we jump straight into building components that will talk to our Smart Contract instance, let’s first actually render a simple text on the screen just to make sure our setup is working correctly.</p><p>For that, what we’ll do is adding React as a dependency to our project. In fact, we’ll be relying on two packages - <code>react</code> and <code>react-dom</code>. The latter is needed to render components defined with React in a DOM environment, which is what a Browser essentially is.</p><p>Let’s add the following <code>dependencies</code> section to our projects <code>package.json</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;react&quot;: &quot;^16.4.2&quot;,</span><br><span class="line">  &quot;react-dom&quot;: &quot;^16.4.2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once that is done we need to actually install those dependencies. For that we simply execute the following command in our terminal of choice:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>Now we can go ahead and actually make use of React. As Embark is framework agnostic, we won’t be focussing too much on details specific to React, just the least amount that is needed to make our app work.</p><p>Creating components in React is pretty straight forward. All we need to do is creating a class that extends React’s <code>Component</code> type and add a <code>render()</code> method that will render the component’s view.</p><p>Let’s create a folder for all of our components inside our projects:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir app/js/components</span><br></pre></td></tr></table></figure><p>Next, we create a file for our root component. We call it simply <code>App</code> and use the same file name:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch app/js/components/App.js</span><br></pre></td></tr></table></figure><p>Alright, as mentioned earlier, we really just want to render some text on the screen for starters. Here’s what that could look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;DReddit&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is probably self explanatory, but all we’re doing here is importing <code>React</code> and its <code>Component</code> type and create an <code>App</code> class that extends <code>Component</code>. The <code>render()</code> method will be used by React to render the component’s view and has to return a template that is written in JSX syntax. JSX looks a lot like HTML just that it comes with extra syntax to embed things like control structures. We’ll make use of that later!</p><p>Okay now that we have this component defined, we need to tell React to actually render this particular component. For that, we head over to <code>app/js/index.js</code> and add the following code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; render &#125; from &apos;react-dom&apos;;</span><br><span class="line">import &#123; App &#125; from &apos;./components/App&apos;;</span><br><span class="line"></span><br><span class="line">render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure><p>We need to import <code>React</code> again as it has to be available in this script’s scope. We also import a <code>render</code> function from <code>react-dom</code>, which is used to render our root component (<code>App</code>) into some element inside our HTML document. In this case we say that the element in which we want to render our root component is the element with the id <code>root</code>.</p><p>Let’s set this up really quick. In <code>app/index.html</code> add a new element with a <code>root</code> id:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>Notice that we’ve also moved the <code>script</code> tag inside the body tag, after the element with the <code>root</code> id. This is just one way to work around the fact that the element we’re referencing inside our <code>render()</code> method is actually available in the document at the time the script is executed.</p><p>That should do it! Let’s spin up Embark, we should then see our component rendered on the screen:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ embark run</span><br></pre></td></tr></table></figure><h2 id="Building-a-CreatePost-component"><a href="#Building-a-CreatePost-component" class="headerlink" title="Building a CreatePost component"></a>Building a <code>CreatePost</code> component</h2><p>Alright, enough warm up. Time to build components that are useful. We start off with building a component that lets users create posts through our application. Similar to <code>App</code>, we’ll introduce a new component <code>createPost</code> that comes with a <code>render()</code> method to display a simple form for entering data. We’ll also need to add event handlers to the form so that when a user submits the form, we can actually access the data and later on send it to our Smart Contract.</p><p>Creating a simple form is very straight forward:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export class CreatePost extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label&gt;Topic&lt;/label&gt;</span><br><span class="line">          &lt;input type=&quot;text&quot; name=&quot;topic&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;button&gt;Post&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To actually render this component on screen, we need to make it part of our <code>App</code> component. Or, to be more specific, have the <code>App</code> component render our <code>CreatePost</code> component. For now we can simply add it to <code>App</code>‘s render function like this;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; CreatePost &#125; from &apos;./CreatePost&apos;;</span><br><span class="line"></span><br><span class="line">export class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;h1&gt;DReddit&lt;/h1&gt;</span><br><span class="line">        &lt;CreatePost /&gt;</span><br><span class="line">      &lt;/React.Fragment&amp;&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React doesn’t allow for multiple root elements in a single component’s view, so we have to take advantage of <code>React.Fragment</code>. Obviously, there’s not too much going on here apart from us rendering a static form. Also notice that we don’t spend too much time and effort on making the form look nice as we focus on the functionality for now. Consider that homework!</p><p>Let’s make this form functional. First of all we want make sure that data entered into the form is available inside our component. React components maintain an object called <code>state</code> that can be used for exactly that. All we have to do is to initialize it with some initial values and update it using a <code>setState()</code> method if needed.</p><p>Let’s introduce <code>state</code> in our component by adding a constructor and initializing it accordingly:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class CreatePost extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    </span><br><span class="line">    this.state = &#123;</span><br><span class="line">      topic: &apos;&apos;,</span><br><span class="line">      content: &apos;&apos;,</span><br><span class="line">      loading: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next we bind that state to our form fields:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label&gt;Topic&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;topic&quot; value=&#123;this.state.topic&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;textarea name=&quot;content&quot; value=&#123;this.state.content&#125;&gt;&lt;/textarea&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button&gt;Post&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>No worries, we’ll make use of <code>loading</code> in a second. Last but not least we want to add some event handlers so that changes in the view will be reflected back to our component’s state as the user is entering data. To make sure everything works fine, we’ll also add an event handler for the form submission and output the data in <code>state</code>. Here’s what our <code>handleChange()</code> and <code>createPost()</code> handlers looks like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class CreatePost extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  handleChange(field, event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [field]: event.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    console.log(this.state);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice how we’re using <code>setState()</code> inside <code>handleChange()</code> to update whatever field name has been passed to that method. Now all we need to do is attach those handlers to our form:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form onSubmit=&#123;e =&gt; createPost(e)&#125;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label&gt;Topic&lt;/label&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">      type=&quot;text&quot; </span><br><span class="line">      name=&quot;topic&quot; </span><br><span class="line">      value=&#123;this.state.topic&#125; </span><br><span class="line">      onChange=&#123;e =&gt; handleChange(&apos;topic&apos;, e)&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;textarea </span><br><span class="line">      name=&quot;content&quot; </span><br><span class="line">      value=&#123;this.state.content&#125; </span><br><span class="line">      onChange=&#123;e =&gt; handleChange(&apos;content&apos;, e&#125;)&gt;&lt;/textarea&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Post&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>Since we’re using the <code>onSubmit()</code> handler of the form, it’s also important that we either add a <code>type=&quot;submit&quot;</code> to our <code>button</code> or change the button to an <code>&lt;input type=&quot;submit&quot;&gt;</code> element. Otherwise, the form won’t emit a submit event.</p><p>Nice! With that in place, we should see the component’s <code>state</code> in the console when submitting the form! The next challenge is to use <code>EmbarkJS</code> and its APIs to make our component talk to our Smart Contract instance.</p><h3 id="Uploading-data-to-IPFS"><a href="#Uploading-data-to-IPFS" class="headerlink" title="Uploading data to IPFS"></a>Uploading data to IPFS</h3><p>Recall from our <a href="/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/#Creating-posts">first part</a> of this tutorial that our <code>DReddit</code> Smart Contract comes with a <code>createPost()</code> method that takes some bytes as post data. Those bytes are actually not the post data itself, but an IPFS hash that points to the post data. In other words, we’ll have to somehow create such a hash and make sure the data is uploaded to IPFS as well.</p><p>Luckily, EmbarkJS comes with plenty of convenient APIs to do exactly that! <code>EmbarkJS.Storage.saveText()</code> takes a string, uploads it to IPFS and returns its hash which can then be used to create a post using our Smart Contract. One thing to keep in mind is that those APIs are asynchronous. Similar to how we wrote tests in <a href="/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2/#Testing-createPost">part two</a> of this tutorial, we’ll use <code>async/await</code> to write asynchronous code in a synchronous fashion.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async createPost(event) &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  </span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    loading: true</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const ipfsHash = await EmbarkJS.Storage.saveText(JSON.stringify(&#123;</span><br><span class="line">    topic: this.state.topic,</span><br><span class="line">    content: this.state.content</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    topic: &apos;&apos;,</span><br><span class="line">    content: &apos;&apos;,</span><br><span class="line">    loading: false</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We use <code>JSON.stringify()</code> on an object that holds the <code>topic</code> and <code>content</code> of the post to be created. This is also the first time we put <code>loading</code> into action. Setting it to <code>true</code> before, and <code>false</code> after we’ve performed our operations lets us render a useful message as the user is waiting for updates.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form onSubmit=&#123;e =&gt; createPost(e)&#125;&gt;</span><br><span class="line">  ...</span><br><span class="line">  &#123;this.state.loading &amp;&amp; </span><br><span class="line">    &lt;p&gt;Posting...&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>Obviously, we’re not done yet though. All we do right now is uploading the post’s data to IPFS and receiving the hash, but we still need to take that hash and send it to our Smart Contract using its <code>createPost()</code> method. Let’s do that!</p><h3 id="Sending-transactions-to-create-posts"><a href="#Sending-transactions-to-create-posts" class="headerlink" title="Sending transactions to create posts"></a>Sending transactions to create posts</h3><p>To send a transaction to our Smart Contract, we can again take advantage of EmbarkJS’ APIs, similar to how we did it in the <a href="/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2">second part</a>. We also need to get hold of an Ethereum account to send the transaction from. This will be very straight forward as we’ll be just relying on the accounts that are generated by the Ethereum node that Embark spins up for us.</p><p>Once we have those things in place we can get a gas estimation for our transaction and send the data over. Here’s how we retrieve our accounts, notice that <code>async/await</code> can be used here as well:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async createPost(event) &#123;</span><br><span class="line">  ...</span><br><span class="line">  const accounts = await web3.eth.getAccounts();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next up we’ll import a <code>DReddit</code> Smart Contract instance from EmbarkJS and use it to get a gas estimation from <code>web3</code>. We can then use the estimation and one of our accounts to actually send the transaction:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import DReddit from &apos;./artifacts/contracts/DReddit&apos;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">async createPost(event) &#123;</span><br><span class="line">  ...</span><br><span class="line">  const accounts = await web3.eth.getAccounts();</span><br><span class="line">  const createPost = DReddit.methods.createPost(web3.utils.toHex(ipfsHash));</span><br><span class="line">  const estimate = await createPost.estimateGas();</span><br><span class="line">  </span><br><span class="line">  await createPost.send(&#123;from: accounts[0], gas: estimate&#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sweet, with that, our <code>createPost</code> method is done! We haven’t built a list of all created posts yet, but if we open up the app and create a post, we can use Embark to double check whether the transaction went through successfully. Simply watch the output in the terminal after running <code>embark run</code>. We should see a confirmation that looks something like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Blockchain&gt; DReddit.createPost(&quot;0x516d5452427a47415153504552614645534173335133765a6b59436633634143776368626263387575623434374e&quot;) | 0xbbeb9fa1eb4e3434c08b31409c137c2129de65eb335855620574c537b3004f29 | gas:136089 | blk:18455 | status:0x1</span><br></pre></td></tr></table></figure><h2 id="Creating-a-Post-component"><a href="#Creating-a-Post-component" class="headerlink" title="Creating a Post component"></a>Creating a Post component</h2><p>The next challenge lies in fetching all created posts from our Smart Contract and IPFS so we can render them on screen. We start simple and first create a new component that will render a single post. After that we’ll look into rendering a list of posts dynamically, based on the data we’re fetching.</p><p>Again, our application won’t look particularly pretty, we’ll just focus on getting the core functionality right. A post component needs to render the post topic, its content, the owner of the post, ideally the date when it has been created, and a button to up and down vote respectively.</p><p>Here’s what such a component with a basic template could look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export class Post extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;h3&gt;Some Topic&lt;/h3&gt;</span><br><span class="line">        &lt;p&gt;This is the content of a post&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&lt;small&gt;&lt;i&gt;created at 2019-02-18 by 0x00000000000000&lt;/i&gt;&lt;/small&gt;&lt;/p&gt;</span><br><span class="line">        &lt;button&gt;Upvote&lt;/button&gt;</span><br><span class="line">        &lt;button&gt;Downvote&lt;/button&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are different ways to make the data being rendered dynamic. Usually, we would probably pass a one or more properties to the <code>Post</code> component that represents the entire post object and can then be displayed inside its <code>render()</code> method. However, for this tutorial we’re going to choose a slightly different path. We’ll make <code>Post</code> receive IPFS hash that’s stored in the Smart Contract and have it resolve the data itself.</p><p>Let’s stay consistent with our naming and say the property we’re expecting to be filled with data is called <code>description</code>, just like the one used inside the Smart Contract. We can then use <code>EmbarkJS.Storage.get()</code> with the IPFS hash to fetch the data that represents the actual post. In order to render the data inside <code>Post</code>‘s view, we’ll parse it and use <code>setState()</code> accordingly.</p><p>To make sure all of that happens once the component is ready to do its work, we’ll do all of that inside its <code>componentDidMount()</code> life cycle hook:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import EmbarkJS from &apos;.artifacts/embarkjs&apos;;</span><br><span class="line"></span><br><span class="line">export class Post extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      topic: &apos;&apos;,</span><br><span class="line">      content: &apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async componentDidMount() &#123;</span><br><span class="line">    const ipfsHash = web3.utils.toAscii(this.props.description);</span><br><span class="line">    const data = await EmbarkJS.Storage.get(ipfsHash);</span><br><span class="line">    const &#123; topic, content &#125; = JSON.parse(data);</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; topic, content &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s one gotcha to keep in mind here: Calling <code>EmbarkJS.Storage.get()</code> or any <code>EmbarkJS</code> function on page load can fail, because the storage system might not be fully initialized yet. This wasn’t a problem for the previous <code>EmbarkJS.Storage.uploadText()</code> because we called that function well after Embark had finished initializing</p><p>Theoretically however, there could be a race condition even for creating a post. To ensure that EmbarkJS is ready at any point in time, we use its <code>onReady()</code> hook. <code>EmbarkJS.onReady()</code> takes a callback which will be executed once EmbarkJS is ready to go. The best place to do this in our app is probably where we attempt to render our application, so let’s wrap that <code>render()</code> call in our <code>App</code> component inside Embark’s <code>onReady()</code> function.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EmbarkJS.onReady(() =&gt; &#123;</span><br><span class="line">  render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>This also means our app will only render when EmbarkJS is ready, which theoretically could take a little longer. However in this tutorial, chances are very low this is becoming a problem.</p><p>Let’s also quickly add the <code>owner</code> and creation date. The <code>owner</code> is expected to be passed down as a property. The same goes for the creation date. We just need to make sure it’ll be formatted in a way the users can make sense of the data. We’ll use the <code>dateformat</code> library for that and install it as a dependency like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save dateformat</span><br></pre></td></tr></table></figure><p>Once that is done, we can update our <code>Post</code> component’s <code>render()</code> function to calculate a properly formatted date based on the <code>creationDate</code> that has been passed down through properties:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">import dateformat from &apos;dateformat&apos;;</span><br><span class="line"></span><br><span class="line">export class Post extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    const formattedDate = dateformat(</span><br><span class="line">      new Date(this.props.creationDate * 1000),</span><br><span class="line">      &apos;yyyy-mm-dd HH:MM:ss&apos;</span><br><span class="line">    );</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;h3&gt;&#123;this.state.topic&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.content&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&lt;small&gt;&lt;i&gt;created at &#123;formattedDate&#125; by &#123;this.props.owner&#125;&lt;/i&gt;&lt;/small&gt;&lt;/p&gt;</span><br><span class="line">        &lt;button&gt;Upvote&lt;/button&gt;</span><br><span class="line">        &lt;button&gt;Downvote&lt;/button&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that variables created inside <code>render()</code> can be interpolated as they are - there’s no need to make them available on <code>props</code> or <code>state</code>. As a matter of fact, <code>props</code> are always considered read only in React.</p><p>Let’s try out our new <code>Post</code> component with some static data by adding it to our <code>App</code> component’s view. Next up, we’ll make this dynamic by fetching the posts from our Smart Contract.</p><p><strong>Attention</strong>: The hash used in this snippet might not be available in your local IPFS node, so you’ll have to get hold of your own hash. This can be down by logging out the hash that is returned from IPFS and convert it to hex code.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;h1&gt;DReddit&lt;/h1&gt;</span><br><span class="line">        &lt;CreatePost /&gt;</span><br><span class="line">        &lt;Post </span><br><span class="line">          description=&quot;0x516d655338444b53464546725369656a747751426d683377626b56707566335770636e4c715978726b516e4b5250&quot;</span><br><span class="line">          creationDate=&quot;1550073772&quot;</span><br><span class="line">          owner=&quot;0x00000000000&quot;</span><br><span class="line">          /&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Creating-a-List-component"><a href="#Creating-a-List-component" class="headerlink" title="Creating a List component"></a>Creating a List component</h2><p>Before we can move on with building a component that renders a list of posts, we’ll have to extend our Smart Contract with one more method. Since there’s no canonical way to fetch array data from a Smart Contract, we’ll be fetching the post data for each post one by one. We do that by first fetching the total number of posts and use that number to iterate over the available indices, which we can then use to fetch the actual posts.</p><p>Let’s introduce a method <code>numPosts()</code> in our <code>DReddit</code> Smart Contract:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function numPosts() public view returns (uint) &#123;</span><br><span class="line">  return posts.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>posts.length</code> will increase as we’re adding posts, so it will always be the single source of truth when it comes to determining indices of posts. This would be a good opportunity to write another test - we’ll leave that up to you!</p><p>With that in place, we can start building a new <code>List</code> component. The <code>List</code> component maintains a list of posts to render on screen, so we can start simple again and introduce the bare minimum like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export class List extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      posts: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;React.Fragment&gt;</span><br><span class="line">      &#123;this.state.posts.map(post =&gt; &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;Post </span><br><span class="line">            key=&#123;post.id&#125;</span><br><span class="line">            description=&#123;post.description&#125;</span><br><span class="line">            creationDate=&#123;post.creationDate&#125;</span><br><span class="line">            owner=&#123;post.owner&#125;</span><br><span class="line">          /&gt;)</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The most interesting part here is probably the <code>render()</code> method, in which we iterate over all <code>state.posts</code> (which at the moment is empty) and then render a <code>Post</code> component for every iteration. Another thing to note is that every <code>Post</code> receives a <code>key</code>. This is required in React when creating views from loops. We’ve never introduced a <code>post.id</code> in this tutorial, but don’t worry, we’ll fix that in a moment.</p><p>We can already put that in our <code>App</code> component. It won’t render anything as we haven’t fetched any posts yet, but that’s what we’ll do next.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; List &#125; from &apos;./List&apos;;</span><br><span class="line"></span><br><span class="line">export class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;h1&gt;DReddit&lt;/h1&gt;</span><br><span class="line">        &lt;CreatePost /&gt;</span><br><span class="line">        &lt;List /&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fetching-posts-data"><a href="#Fetching-posts-data" class="headerlink" title="Fetching posts data"></a>Fetching posts data</h3><p>Let’s fill our new <code>List</code> component with life! As mentioned earlier, we’ll use our Smart Contract’s <code>numPosts()</code> method to get hold of the total number of posts available. We then use that number to iterate over all indices and request every post individually. Since this is logic we want to execute once the <code>List</code> component is ready, we’ll use its <code>componentDidMount()</code> method for that:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class List extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  async componentDidMount() &#123;</span><br><span class="line">    const totalPosts = await DReddit.methods.numPosts().call();</span><br><span class="line"></span><br><span class="line">    let list = [];</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; totalPosts; i++) &#123;</span><br><span class="line">      const post = DReddit.methods.posts(i).call();</span><br><span class="line">      list.push(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list = await Promise.all(list);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that in the above code we don’t <code>await</code> the calls to every individual post. This is on purpose as we don’t want to wait on each and every promise to resolve, but first collect all of the promises we need and then resolve them all in one go using <code>Promise.all().</code></p><p>Last but not least, we need to add an <code>id</code> property to every post as mentioned earlier. This is easily done by simply iterating over all posts and assigning the post’s index as <code>id</code>. Once that is done, we can use <code>setState()</code> to update our component’s state and render the list:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async componentDidMount() &#123;</span><br><span class="line">  ...</span><br><span class="line">  list = list.map((post, index) =&gt; &#123;</span><br><span class="line">    post.id = index;</span><br><span class="line">    return post;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  this.setState(&#123; posts: list &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That’s it! Our application now renders a list of all created posts. Unfortunately, posts are not being re-fetched  automatically when adding new posts. For the time being, we’ll have to reload the browser every time after adding a post. However, this we’ll address now.</p><h3 id="Reloading-posts"><a href="#Reloading-posts" class="headerlink" title="Reloading posts"></a>Reloading posts</h3><p>There is certainly different ways to make the list of posts update automatically, so take the following approach with a grain of salt. What we need is a way to have the <code>createPost</code> component tell the <code>List</code> component to reload its posts. However, there’s no communication layer in place when building a simple React app like this, so the most straight forward way to make this possible, is to move the logic of loading the posts in the parent component of <code>CreatePost</code> and <code>List</code> (in our case <code>App</code>), and have it pass that logic down to places where its needed. This also means we’ll be fetching the list inside <code>App</code> and pass down the pure data to <code>List</code>.</p><p>If this sounds overwhelming, no worries, it’s more trivial than that! Let’s start by introducing a <code>loadPosts()</code> function in our <code>App</code> component. Essentially we’re moving everything from <code>List</code>‘s <code>componentDidMount()</code> function into <code>App</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class App extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  async loadPosts() &#123;</span><br><span class="line">    const totalPosts = await DReddit.methods.numPosts().call();</span><br><span class="line"></span><br><span class="line">    let list = [];</span><br><span class="line"></span><br><span class="line">    if (totalPosts &gt; 0) &#123;</span><br><span class="line">      for (let i = 0; i &lt; totalPosts; i++) &#123;</span><br><span class="line">        const post = DReddit.methods.posts(i).call();</span><br><span class="line">        list.push(post);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list = await Promise.all(list);</span><br><span class="line">    list = list.map((post, index) =&gt; &#123;</span><br><span class="line">      post.id = index;</span><br><span class="line">      return post;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    list;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; posts: list &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To make this work we also need to introduce a <code>state</code> with the dedicated <code>posts</code>. After that, we make sure <code>loadPosts()</code> is called when <code>App</code> is mounted:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      posts: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async componentDidMount() &#123;</span><br><span class="line">    await this.loadPosts();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Last but not least, all we have to do is to pass the <code>posts</code> down to <code>List</code> and <code>loadPosts()</code> to <code>CreatePost</code> as a callback handler if you will:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;h1&gt;DReddit&lt;/h1&gt;</span><br><span class="line">      &lt;CreatePost afterPostHandler=&#123;this.loadPosts.bind(this)&#125;/&gt;</span><br><span class="line">      &lt;List posts=&#123;this.state.posts&#125;/&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once that is done, we can consume <code>posts</code> and <code>afterPostHandler()</code> from <code>this.props</code> respectively. In <code>List</code>‘s <code>render()</code> function we’ll do (notice we don’t rely on <code>this.state</code> anymore):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (&lt;React.Fragment&gt;</span><br><span class="line">    &#123;this.props.posts.map(post =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)&#125;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And in <code>CreatePost</code> we call <code>afterPostHandler()</code> after a post has been created:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async createPost(event) &#123;</span><br><span class="line">  ...</span><br><span class="line">  await createPost.send(&#123;from: accounts[0], gas: estimate&#125;);</span><br><span class="line">  await this.props.afterPostHandler();</span><br><span class="line"></span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    topic: &apos;&apos;,</span><br><span class="line">    content: &apos;&apos;,</span><br><span class="line">    loading: false</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wonderful! The list now automatically reloads after creating posts, give it a try!</p><h2 id="Add-voting-functionality"><a href="#Add-voting-functionality" class="headerlink" title="Add voting functionality"></a>Add voting functionality</h2><p>The final feature we’ll be implementing is the up and down voting of posts. This is where we come back to our <code>Post</code> component that we’ve created earlier. In order to make this feature complete we’ll have to:</p><ul><li>Render the number of up and down votes per post</li><li>Add handlers for users to up and down vote</li><li>Determine if a user can vote on a post</li></ul><h3 id="Rendering-number-of-votes"><a href="#Rendering-number-of-votes" class="headerlink" title="Rendering number of votes"></a>Rendering number of votes</h3><p>Let’s start with the first one, as it’s the most trivial one. While the number of up and down votes is already attached to the data that we receive from our <code>DReddit</code> Smart Contract, it’s not yet in the right format as it comes back as a string. Let’s make sure we parse the up and down vote counts on posts by extending our <code>App</code>‘s <code>loadPosts()</code> method like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async loadPosts() &#123;</span><br><span class="line">  ...</span><br><span class="line">  list = list.map((post, index) =&gt; &#123;</span><br><span class="line">    post.id = index;</span><br><span class="line">    post.upvotes = parseInt(post.upvotes, 10);</span><br><span class="line">    post.downvotes = parseInt(post.downvotes, 10);</span><br><span class="line">    return post;</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once that is done we can pass each post’s <code>upvotes</code> and <code>downvotes</code> to every <code>Post</code> component via its <code>props</code> inside our <code>List</code> component:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class List extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;React.Fragment&gt;</span><br><span class="line">      &#123;this.props.posts.map(post =&gt; &#123;</span><br><span class="line">        return (&lt;Post </span><br><span class="line">          key=&#123;post.id&#125;</span><br><span class="line">          description=&#123;post.description&#125;</span><br><span class="line">          creationDate=&#123;post.creationDate&#125;</span><br><span class="line">          upvotes=&#123;post.upvotes&#125;</span><br><span class="line">          downvotes=&#123;post.downvotes&#125;</span><br><span class="line">          owner=&#123;post.owner&#125;</span><br><span class="line">          /&gt;)</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rendering the number of <code>upvotes</code> and <code>downvotes</code> is then really just a matter of interpolating them in <code>Post</code>‘s <code>render()</code> function. We’re just going to add them next to the buttons, but feel free to put them somewhere else:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class Post extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    ...</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        ...</span><br><span class="line">        &#123;this.props.upvotes&#125; &lt;button&gt;Upvote&lt;/button&gt;</span><br><span class="line">        &#123;this.props.downvotes&#125; &lt;button&gt;Downvote&lt;/button&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Implement-up-and-down-votes"><a href="#Implement-up-and-down-votes" class="headerlink" title="Implement up and down votes"></a>Implement up and down votes</h3><p>Similar to when creating new posts, making the up and down vote buttons work requires sending transactions to our <code>DReddit</code> Smart Contract. So we’ll do almost the same thing as in our <code>CreatePost</code> component, just that we’re calling the Smart Contract’s <code>vote()</code> method. If you recall, the <code>vote()</code> method takes a post id and the vote type, which is either <code>NONE</code>, <code>UPVOTE</code> or <code>DOWNVOTE</code> and are stored as <code>uint8</code>.</p><p>It makes sense to introduce the same representation in our app so we can use descriptive names, but rely on uint values at the same time. There are no enum data structures in JavaScript so we’ll use a hash object instead:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const BALLOT = &#123;</span><br><span class="line">  NONE: 0,</span><br><span class="line">  UPVOTE: 1,</span><br><span class="line">  DOWNVOTE: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We don’t actually have the post id available in our <code>Post</code> component yet. That’s easily added in our <code>List</code> component, by now you should know how to do that!</p><p>We can then add click handlers to our up and down vote buttons and pass one of the <code>BALLOT</code> types to them (notice that we added <code>BALLOT.NONE</code> only for completeness-sake but don’t actually use it in our code):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;e =&gt; this.vote(BALLOT.UPVOTE)&#125;&gt;Upvote&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;e =&gt; this.vote(BALLOT.DOWNVOTE)&#125;&gt;Downvote&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>The next thing we need to do is sending that vote type along with the post id to our Smart Contract:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async vote(ballot) &#123;</span><br><span class="line">  const accounts = await web3.eth.getAccounts();</span><br><span class="line">  const vote = DReddit.methods.vote(this.props.id, ballot);</span><br><span class="line">  const estimate = await vote.estimateGas();</span><br><span class="line"></span><br><span class="line">  await vote.send(&#123;from: accounts[0], gas: estimate&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Obviously, we also want to update the view when a vote has been successfully sent. Right now we’re reading a post’s up and down votes from its <code>props</code> and render them accordingly. However, we want to update those values as votes are coming in. For that we’ll change our code to only read the up and down votes from <code>props</code> once and store them in the component’s state.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class Post extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      topic: &apos;&apos;,</span><br><span class="line">      content: &apos;&apos;,</span><br><span class="line">      upvotes: this.props.upvotes,</span><br><span class="line">      downvotes: this.props.downvotes</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We also change the component’s view to render the values from state instead of <code>props</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  ...</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      ...</span><br><span class="line">      &#123;this.state.upvotes&#125; &lt;button ...&gt;Upvote&lt;/button&gt;</span><br><span class="line">      &#123;this.state.downvotes&#125; &lt;button ...&gt;Downvote&lt;/button&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After that we can update the state with new votes using <code>setState()</code>, right after a vote has been sent:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async vote(ballot) &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    upvotes: this.state.upvotes + (ballot == BALLOT.UPVOTE ? 1 : 0),</span><br><span class="line">    downvotes: this.state.downvotes + (ballot == BALLOT.DOWNVOTE ? 1 : 0)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>That’s it!</strong> We can now up and down vote on posts…but only once! Yes, that’s right. When we try to vote multiple times on the same post, we’ll actually receive an error. That’s because, if you remember, there’s a restriction in our Smart Contract that makes sure users can not vote on posts that they’ve either already voted on, or created themselves.</p><p>Let’s make sure this is reflected in our application’s UI and wrap up this tutorial!</p><h3 id="Use-canVote-to-disable-vote-buttons"><a href="#Use-canVote-to-disable-vote-buttons" class="headerlink" title="Use canVote() to disable vote buttons"></a>Use <code>canVote()</code> to disable vote buttons</h3><p>We’ll keep this one very simple - if a user cannot vote on a post, the voting buttons should be simply disabled. We can easily determine whether a user is allowed to vote by calling our Smart Contract’s <code>canVote()</code> method. Another thing we need to consider is that we shouldn’t allow a user to vote when a vote for the same post is already in flight but hasn’t completed yet.</p><p>Let’s introduce a new state properties for that first. In general we can say that a user is allowed to vote, and that she is not submitting a vote in this very moment:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class Post extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      topic: &apos;&apos;,</span><br><span class="line">      content: &apos;&apos;,</span><br><span class="line">      upvotes: this.props.upvotes,</span><br><span class="line">      downvotes: this.props.downvotes,</span><br><span class="line">      canVote: true,</span><br><span class="line">      submitting: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, we update our <code>Post</code> component’s <code>render()</code> function to disable the voting buttons if a vote is in flight, or a user is simply not allowed to vote:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  ...</span><br><span class="line">  const disabled = this.state.submitting || !this.state.canVote;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      ...</span><br><span class="line">      &#123;this.state.upvotes&#125; &lt;button disabled=&#123;disabled&#125; ...&gt;Upvote&lt;/button&gt;</span><br><span class="line">      &#123;this.state.downvotes&#125; &lt;button disabled=&#123;disabled&#125; ...&gt;Downvote&lt;/button&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Last but not least, we have to make sure the state properties are updated accordingly. We’ll call our Smart Contract’s <code>canVote()</code> method when a post is initialized:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class Post extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">  async componentDidMount() &#123;</span><br><span class="line">    ...</span><br><span class="line">    const canVote = await DReddit.methods.canVote(this.props.id).call();</span><br><span class="line">    this.setState(&#123; topic, content, canVote &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And when a vote is being made, we set <code>submitting</code> to <code>true</code> right before we send a transaction and set it back to <code>false</code> again when the transaction is done. At this point, we also know that a vote has been made on this post, so <code>canVote</code> can be set to <code>false</code> at the same time:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async vote(ballot) &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.setState(&#123; submitting: true &#125;);</span><br><span class="line">  await vote.send(&#123;from: accounts[0], gas: estimate + 1000&#125;);</span><br><span class="line"></span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    ...</span><br><span class="line">    canVote: false,</span><br><span class="line">    submitting: false</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>And we’re done!</strong></p><h2 id="Wrapping-it-up"><a href="#Wrapping-it-up" class="headerlink" title="Wrapping it up"></a>Wrapping it up</h2><p>Congratulations! You’ve completed the tutorial on building a simple decentralized Reddit application! You might have noticed that this is only the tip of the iceberg though, as there are so many things that can be done to improve and optimize this application. Here are some ideas for further exploration:</p><ul><li>Sort the posts in reversed chronological order so that the latest post is always on top</li><li>Rely on Smart Contracts Events to reload list</li><li>Introduce routing so there can be different views for creating and viewing posts</li><li>Use CSS to make the application look nice</li></ul><p>We hope you’ve learned that it’s not too hard to build a DApp that uses IPFS and talks to Smart Contracts, and also how Embark can help you doing all of these things.</p><p><strong>We’ve recorded every single step of this tutorial <a href="https://github.com/embark-framework/dreddit-tutorial" target="_blank" rel="noopener">in this repository</a></strong>, so feel free to go ahead, clone it, play with it, compare it with your work or change it to your needs. There will be more tutorials of this kind in the future, so make sure to <a href="https://twitter.com/EmbarkProject" target="_blank" rel="noopener">follow us on Twitter</a> as well for updates!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hopefully you’ve read &lt;a href=&quot;/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/&quot;&gt;the first&lt;/a&gt; and &lt;a href=&quot;/news/201
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Building a decentralized Reddit with Embark - Part 2</title>
    <link href="https://embark.status.im/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2/"/>
    <id>https://embark.status.im/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2/</id>
    <published>2019-02-11T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.270Z</updated>
    
    <content type="html"><![CDATA[<p>In <a href="/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/">the first part of this tutorial</a> we’ve implemented a <code>DReddit</code> Smart Contract that comes with methods to create and vote on topic posts. In this part we’ll continue right where we’ve left off and take a closer look at how we can test our Smart Contract using Embark. Make sure to check out the other parts as well:</p><ul><li><a href="/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/"><strong>Part 1</strong> - Setting up the project and implementing a Smart Contract</a></li><li><a href="/news/2019/02/18/building-a-decentralized-reddit-with-embark-part-3/"><strong>Part 3</strong> - Building a simple front-end using React</a></li></ul><p><strong>The code for this tutorial can be found in <a href="https://github.com/embark-framework/dreddit-tutorial" target="_blank" rel="noopener">this repository</a></strong>.</p><p>And off we go!</p><h2 id="Writing-a-first-test"><a href="#Writing-a-first-test" class="headerlink" title="Writing a first test"></a>Writing a first test</h2><p>We’ve got plenty functionality to cover in our tests, but let’s start with a very simple one just to get a bit more familiar with how to write tests and also to ensure things are working as intended. First we create a test file <code>DReddit_spec.js</code> inside <code>test</code> and add a <code>contract()</code> block that looks something like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract(&apos;DReddit&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Inside this code block we’ll be putting dedicated test cases. The <code>contract()</code> function can be considered a “grouping” functionality to group tests, if you will. If you’re familiar with Mocha’s <a href="https://mochajs.org/" target="_blank" rel="noopener">describe()</a> function, you already know how <code>contract()</code> works, as it’s pretty much just an alias.</p><p>To check whether our test setup is working, we add a simple test that passes:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract(&apos;DReddit&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  it (&apos;should work&apos;, () =&gt; &#123;</span><br><span class="line">    assert.ok(true);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Running this using Embark’s <code>test</code> command should result in an output similar to this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ embark test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiling contracts</span><br><span class="line">  DReddit</span><br><span class="line">    ✓ should work (0ms) - [0 gas]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (5s) - [Total: 2210775 gas]</span><br><span class="line"></span><br><span class="line"> &gt; All tests passed</span><br></pre></td></tr></table></figure><p>This works great, let’s go ahead and test some actual functionality!</p><h2 id="Testing-the-creation-of-post"><a href="#Testing-the-creation-of-post" class="headerlink" title="Testing the creation of post"></a>Testing the creation of post</h2><p>Let’s test the core functionality of our application - the creation of posts. For that we need to do a couple of things: We need to somehow get an instance of our <code>DReddit</code> Smart Contract in JavaScript, so we can call methods on it to test if they work, and we also need to configure out testing environment so that the right Smart Contract instances are created.</p><h3 id="Requiring-Smart-Contract-instances"><a href="#Requiring-Smart-Contract-instances" class="headerlink" title="Requiring Smart Contract instances"></a>Requiring Smart Contract instances</h3><p>When running tests, Embark adds a couple of custom functions and objects to the global scope, which are necessary. One of those functions is a custom <code>require()</code> that lets us import Smart Contract instances from an Embark specific path. This is done so that we can easily import </p><p>For example, in order to get an instance of our <code>DReddit</code> Smart Contract within the test, we add the following line to our spec file:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const DReddit = require(&apos;Embark/contracts/DReddit&apos;);</span><br></pre></td></tr></table></figure><p><code>DReddit</code> is now supposed to be an EmbarkJS Smart Contract instance, but we need to be very careful here. <strong>In reality, this object is empty</strong>. This is because at the time this file is processed, the Smart Contract might not be deployed yet. As a matter of fact, we need to make use of another function, <code>config()</code>, to let Embark know, which Smart Contracts we’re interested in in the first place. This might be a little confusing, but really the bottom line is that <code>DReddit</code> isn’t what we think it is, until we use it inside <code>contract()</code>.</p><p>Let’s add the mentioned <code>config()</code> function so Embark knows what we need:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config(&#123;</span><br><span class="line">  contracts: &#123;</span><br><span class="line">    DReddit: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>This is very similar to <a href="/docs/contracts_configuration.html">configuring Smart Contracts</a>, in fact it’s the test environment equivalent. We pass a configuration object to <code>config()</code> with specific parameters for every Smart Contract we need. In our case, we just need to add <code>DReddit</code> without any additional parameters. This is because our Smart Contract doesn’t need constructor values and things alike. Keep in mind, if we don’t call this <code>config()</code> function, the imported objects for our Smart Contract instances will always be empty.</p><h3 id="Testing-createPost"><a href="#Testing-createPost" class="headerlink" title="Testing createPost()"></a>Testing <code>createPost()</code></h3><p>To test our Smart Contract’s <code>createPost()</code> method, we’ll make use of <code>DReddit</code>, which will now be a Smart Contract instance. If you remember, <code>createPost()</code> actually takes the post’s description as bytes, so how do we make that work? Well, it turns out that we actually don’t pass it the description itself, but an <strong>IPFS hash</strong> that points to the actual description. The reason for that is that posts can be very long, resulting in a lot of bytes. It’s better to store the actual description in a storage where data size isn’t an issue, and instead store a reference to that data in our Smart Contract. Using a hash makes the data size deterministic as it will always have the same length.</p><p>Once we have such a hash (no worries, we’ve got one prepared), we can use Web3’s <code>fromAscii()</code> utils to convert that hash to bytes and then send it off using our Smart Contract’s <code>createPost()</code> method. We can then subscribe to the events we’re emitting and check its return value like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const ipfsHash = &apos;Qmc5gCcjYypU7y28oCALwfSvxCBskLuPKWpK4qpterKC7z&apos;;</span><br><span class="line"></span><br><span class="line">contract(&apos;DReddit&apos;, () =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  it (&apos;should be able to create a post and receive it via contract event&apos;, async () =&gt; &#123;</span><br><span class="line">    const receipt = await DReddit.methods.createPost(web3.utils.fromAscii(ipfsHash)).send();</span><br><span class="line">    const event = receipt.events.NewPost;</span><br><span class="line">    postId = event.returnValues.postId;</span><br><span class="line">    assert.equal(web3.utils.toAscii(event.returnValues.description), ipfsHash);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Notice that we’re using <code>async/await</code> here because Embark’s Smart Contract instance methods return promises. The same can be done without promises as well, it’s just a syntactical difference at this point. Running <code>embark test</code> should result in two passing tests now!</p><h2 id="Testing-correctness-of-data"><a href="#Testing-correctness-of-data" class="headerlink" title="Testing correctness of data"></a>Testing correctness of data</h2><p>Another good test case would be to check if the stored data such as the description bytes, the owner etc.  resolve back to the correct data. Notice that this is slightly different from what we’re testing in our previous test - there we’re testing the description bytes emitted by the <code>NewPost</code> event. To test this we take advantage of the <code>postId</code> created in the previous test, which is available globally now, to fetch the stored post. We then perform a similar check as in the previous test. We also want to test if the owner data of the post is correct, but for that we need to get access to the account that created the post in the first place.</p><p>Luckily wallet accounts can be easily accessed as they are emitted by Embark’s <code>config()</code> function. All we have to do is attaching a resolution handler to <code>config()</code> and storing the emitted value:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">let accounts = [];</span><br><span class="line"></span><br><span class="line">config(&#123;</span><br><span class="line">  contracts: &#123;</span><br><span class="line">    DReddit: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, (err, _accounts) =&gt; &#123;</span><br><span class="line">  accounts = _accounts;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Having that in place, our next test could look something like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it (&apos;post should have correct data&apos;, async () =&gt; &#123;</span><br><span class="line">  const post = await DReddit.methods.posts(postId).call();</span><br><span class="line">  assert.equal(web3.utils.toAscii(post.description), ipfsHash);</span><br><span class="line">  assert.equal(post.owner, accounts[0]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>You might notice that we’re referring to <code>accounts[0]</code> here. However, just by looking at the code, we can’t really know if <code>accounts[0]</code> is really the one we’re expecting. This is where Embark offers another helping hand. When the <code>accounts</code> are set up, Embark will automatically set the first account of the wallet (<code>accounts[0]</code>) to the default account that’ll be used for all transactions. With that knowledge we can make an assertion, expecting <code>accounts[0]</code> to be the owner of the post. </p><p>Another way would be to just always explicitly pass any of the accounts to a Smart Contract method’s <code>send()</code> function, in which case we’d have full control over which account of the wallet will be used.</p><h2 id="Testing-canVote"><a href="#Testing-canVote" class="headerlink" title="Testing canVote()"></a>Testing <code>canVote()</code></h2><p>Alright, next up let’s quickly test if our <code>canVote()</code> method works the way as expected. As voting on posts that don’t exist should never work, we will simply call <code>canVote()</code> on a post id that doesn’t exist. This test is pretty straight forward:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it(&apos;should not be able to vote in an unexisting post&apos;, async () =&gt; &#123;</span><br><span class="line">  const userCanVote = await DReddit.methods.canVote(&quot;123&quot;).call();</span><br><span class="line">  assert.equal(userCanVote, false);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>We also want to make sure that <code>canVote()</code> resolves to <code>true</code> in case a user can indeed vote a certain post. We can again reuse the <code>postId</code> that we’ve stored earlier:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it(&apos;should be able to vote in a post if account has not voted before&apos;, async () =&gt; &#123;</span><br><span class="line">  const userCanVote = await DReddit.methods.canVote(postId).call();</span><br><span class="line">  assert.equal(userCanVote, true);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Wonderful, we have 5 passing tests now!</p><h2 id="Testing-vote"><a href="#Testing-vote" class="headerlink" title="Testing vote()"></a>Testing <code>vote()</code></h2><p>Of course we want to test whether one of our application’s core features works as well. There’s certainly different ways to verify whether <code>vote()</code> does what it’s supposed to do, but for this tutorial we’ll simply check whether the owner account of the vote emitted by the <code>NewVote</code> event is the same as the account that performed the vote. We can actually take some inspiration from our previous tests:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it(&quot;should be able to vote in a post&quot;, async () =&gt; &#123;</span><br><span class="line">  const receipt = await DReddit.methods.vote(postId, 1).send();</span><br><span class="line">  const Vote = receipt.events.NewVote;</span><br><span class="line">  assert.equal(Vote.returnValues.owner, accounts[0]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Test-that-only-one-vote-per-post-is-allowed"><a href="#Test-that-only-one-vote-per-post-is-allowed" class="headerlink" title="Test that only one vote per post is allowed"></a>Test that only one vote per post is allowed</h2><p>The last but essential functionality we want to test is that whether our Smart Contract allows users to vote multiple times on the same post, which for obvious reasons shouldn’t be possible. Using the <code>async/await</code> syntax we can test this very nicely by adding a <code>try/catch</code> block. When a user votes on a post she has already voted on, <code>vote()</code> will fail in which case we can make our assertions accordingly:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it(&apos;should not be able to vote twice&apos;, async () =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const receipt = await DReddit.methods.vote(postId, 1).send();</span><br><span class="line">    assert.fail(&apos;should have reverted&apos;);</span><br><span class="line">  &#125; catch (error)&#123;</span><br><span class="line">    assert(error.message.search(&apos;revert&apos;) &gt; -1, &apos;Revert should happen&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>This might look a bit confusing first but it’s actually pretty straight forward. In case <code>vote()</code> fails, we should not reach the <code>assert.fail()</code> call but end up in the <code>catch()</code> block immediately. If that was not the case, the test would fail. This is a very common pattern when testing negatives.</p><p>Okay, one last time we run <code>embark test</code> and if the output looks like the following, we’re fully covered in terms of tests!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ embark test</span><br><span class="line">Compiling contracts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  DReddit</span><br><span class="line">    ✓ should work (0ms) - [0 gas]</span><br><span class="line">    ✓ should be able to create a post and receive it via contract event (60ms) - [160689 gas]</span><br><span class="line">    ✓ post should have correct data (18ms) - [0 gas]</span><br><span class="line">    ✓ should not be able to vote in an unexisting post (14ms) - [0 gas]</span><br><span class="line">    ✓ should be able to vote in a post if account hasn&apos;t voted before (12ms) - [0 gas]</span><br><span class="line">    ✓ should be able to vote in a post (42ms) - [65115 gas]</span><br><span class="line">    ✓ shouldn&apos;t be able to vote twice (37ms) - [22815 gas]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  7 passing (5s) - [Total: 3130955 gas]</span><br><span class="line"></span><br><span class="line"> &gt; All tests passed</span><br></pre></td></tr></table></figure><p> Awesome! If you run into any issues, check out the repository with all steps recorded <a href="https://github.com/embark-framework/dreddit-tutorial" target="_blank" rel="noopener">here</a>. In <a href="/news/2019/02/18/building-a-decentralized-reddit-with-embark-part-3/">the next and last part of this series</a>, we’ll be building a front-end for our DReddit app using React. Until then, feel free to add more tests as you like!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In &lt;a href=&quot;/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/&quot;&gt;the first part of this tutorial&lt;/a&gt; we’ve implemented a
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Building a decentralized Reddit with Embark - Part 1</title>
    <link href="https://embark.status.im/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/"/>
    <id>https://embark.status.im/news/2019/02/04/building-a-decentralized-reddit-with-embark-part-1/</id>
    <published>2019-02-04T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>In this tutorial we want to get very practical and build a decentralized Reddit application from scratch using Embark. The goal is to get a better idea of not only what parts and components are involved when building such an application, but also which steps are required to get there, without getting too overwhelmed.</p><p>This tutorial is split up into three parts, so every individual part can get our full attention. The three parts are going to be:</p><ul><li><strong>Part 1</strong> - Setting up the project and implementing a Smart Contract</li><li><a href="/news/2019/02/11/building-a-decentralized-reddit-with-embark-part-2/"><strong>Part 2</strong> - Testing the Smart Contract through EmbarkJS</a></li><li><a href="/news/2019/02/18/building-a-decentralized-reddit-with-embark-part-3/"><strong>Part 3</strong> - Building a simple front-end using React</a></li></ul><p><strong>The code for this tutorial can be found in <a href="https://github.com/embark-framework/dreddit-tutorial" target="_blank" rel="noopener">this repository</a></strong>.</p><p>Let’s get right to it!</p><h2 id="Functionality-Overview"><a href="#Functionality-Overview" class="headerlink" title="Functionality Overview"></a>Functionality Overview</h2><p>Alright, let’s start off with quickly talking about what exactly it is that we want to build. Obviously, Reddit is a pretty sophisticated platform so we won’t be able to rebuild it completely. Instead, we’ll be focusing on some key features that will also demonstrate very nicely how Embark can help building such an application.</p><p>The idea is very simple: Our app is called <strong>DReddit</strong> which lets users post topics and everyone else should be able to up and downvote topics. A user account is coupled to an Ethereum wallet account. Essentially every wallet account is a valid account for the application and users can authenticate using extensions like Metamask.</p><p>We will create a Smart Contract that implements the features of posting topics and voting on them. There’s going to be a UI as well, built with React, but we’ll do that in the third part of this series.</p><h2 id="Setting-up-the-application"><a href="#Setting-up-the-application" class="headerlink" title="Setting up the application"></a>Setting up the application</h2><p>If you’ve read our guide on <a href="/docs/create_project.html">Creating Applications</a> or our last tutorial on <a href="/news/2019/01/22/building-smart-contract-only-dapps/">Building Smart Contract only apps</a>, you know that Embark comes with a <code>new</code> command to scaffold an application. We’re going to do exactly that, but first we need to make sure Embark is installed. For a complete guide on installing Embark, head over to <a href="/docs/installation.html">our docs</a>, otherwise, simply run the following command in your terminal of choice:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g embark</span><br></pre></td></tr></table></figure><p>Next, we’ll create and set up our app using the <code>new</code> command:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ embark new dreddit</span><br><span class="line">$ cd dreddit</span><br></pre></td></tr></table></figure><p>Now is a good time to familiarize ourselves with the project structure. The most important directories in are <code>contracts</code>, this is where out Smart Contracts go, and <code>app</code>, which will be our front-end. Take your time to take a look and check out our <a href="/docs/structure.html">Application Structure</a> guide for more detailed overview.</p><p>Also, to ensure and double-check that everything’s working, we can run the application using Embark’s <code>run</code> command:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ embark run</span><br></pre></td></tr></table></figure><p>If there are any issues in the “Available Services” section of the dashboard, go back to our <a href="/docs/installation.html">installation guide</a> and make sure all tools are available on your machine.</p><h2 id="Creating-the-Smart-Contract"><a href="#Creating-the-Smart-Contract" class="headerlink" title="Creating the Smart Contract"></a>Creating the Smart Contract</h2><p>Alright, next up we want to create the brain of our application, which is a Smart Contract written in <a href="https://solidity.readthedocs.io/en/v0.5.3/" target="_blank" rel="noopener">Solidity</a>, that enables creating posts and votes. We’re going to build it up step by step and afterwards we’ll add some tests to ensure our code is actually working.</p><p>First thing we do is creating a file <code>DReddit.sol</code> inside <code>contracts</code> with a Smart Contract like this:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e60702a0-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e60702a0-70c8-11e9-81be-65ee94083d3d">pragma solidity ^0.5.0;contract DReddit {}</code></pre><p>Great! With that in place, let’s introduce a couple of data structures for creating and storing topic posts. Let’s say a post will have a creation date, a description and an address of the owner. There’s a few more things we’ll have to add, but let’s do it one step at a time. Here’s what a <code>Post</code> struct could look like:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e6216872-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e6216872-70c8-11e9-81be-65ee94083d3d">struct Post {  uint creationDate;     bytes description;     address owner;}</code></pre><p>We’re also going to add an array to store all of our posts. Now that we have a <code>Post</code> struct, this is a simple as:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e631e332-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e631e332-70c8-11e9-81be-65ee94083d3d">Post [] public posts;</code></pre><h3 id="Creating-posts"><a href="#Creating-posts" class="headerlink" title="Creating posts"></a>Creating posts</h3><p>It’s time to add our first method which will enable users to add new posts to the platform. For that, we’ll create the method <code>createPost(bytes _description)</code> where <code>_description</code> are the bytes that represent the posts text.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e637af90-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e637af90-70c8-11e9-81be-65ee94083d3d">function createPost(bytes _description) public {  uint postId = posts.length++;  posts[postId] = Post({    creationDate: block.timestamp,    description: _description,    owner: msg.sender  });}</code></pre><p>The first thing we do is creating an id for the post to be stored. We then use our <code>Post</code> struct to create a new post instance. Notice that we leverage the <code>postId</code> when storing the Post in our <code>posts</code> array. To set the owner, we take advantage of Solidity’s global <code>msg</code> object which is available in every transaction. </p><h3 id="Emitting-events"><a href="#Emitting-events" class="headerlink" title="Emitting events"></a>Emitting events</h3><p>As we’re planning to build a front-end that reacts to posts being created, we need to emit an event so the front-end can subscribe to it accordingly. For that, we first introduce a new event type <code>NewPost</code> which will look something like this:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b0af0-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b0af0-70c8-11e9-81be-65ee94083d3d">event NewPost(  uint indexed postId,  address owner,  bytes description)</code></pre><p>Once that is done, all we have to do is emit <code>NewPost</code> inside <code>createPost()</code> with the required data:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3202-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3202-70c8-11e9-81be-65ee94083d3d">function createPost(bytes _description) public {  ...  emit NewPost(postId, msg.sender, _description);}</code></pre><h3 id="Up-and-down-voting-posts"><a href="#Up-and-down-voting-posts" class="headerlink" title="Up and down voting posts"></a>Up and down voting posts</h3><p>As mentioned earlier, Reddit allows for up and down voting topic posts. In order to get the same functionality, we need to extend our <code>Post</code> struct with vote counters, as well as introducing an enum that will represent the available vote types. We also add a new event <code>NewVote</code> for the same reasons we’ve introduced <code>NewPost</code> earlier. Once that is done, we can add a method that performs actual votes.</p><p>Let’s start by adding an enum type calld <code>Ballot</code> that aggregates possible vote types:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Ballot &#123; NONE, UPVOTE, DOWNVOTE &#125;</span><br></pre></td></tr></table></figure><p>To store votes on posts, we’ll add an <code>upvotes</code> and <code>downvotes</code> counter to our <code>Post</code> struct accordingly. We’ll also add a mapping that stores all the voters, so we can check and ensure that nobody tries to vote multiple times:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Post &#123;</span><br><span class="line">  ...</span><br><span class="line">  uint upvotes;</span><br><span class="line">  uint downvotes;</span><br><span class="line">  mapping(address =&gt; Ballot) voters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s the <code>NewPost</code> event which we’ll use in a few moments:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3205-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3205-70c8-11e9-81be-65ee94083d3d">event NewVote(  uint indexed postId,  address owner,  uint8 vote);</code></pre><p>Last but not least, we have to update our <code>createPost()</code> function as the <code>Post</code> struct now needs <code>upvotes</code> and <code>downvotes</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createPost(bytes _description) public &#123;</span><br><span class="line">  ...</span><br><span class="line">  posts[postId] = Post(&#123;</span><br><span class="line">    ...</span><br><span class="line">    upvotes: 0,</span><br><span class="line">    downvotes: 0</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With these building blocks at hand, let’s implement a <code>vote(uint postId, uint8 _vote)</code> method. <code>_vote</code> is going to be one of our defined <code>Ballot</code> types and is represented as uint going from 0 - 2. We’ll use Solidity’s <code>require()</code> statement to ensure we only vote on posts that actually exist, as well as nobody can actually vote multiple times on the same post. </p><p>We then increment the up or down vote counter respectively, store the voter and emit a <code>NewVote</code> event:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3207-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3207-70c8-11e9-81be-65ee94083d3d">function vote(uint _postId, uint8 _vote) public {  Post storage post = posts[_postId];  require(post.creationDate != 0, &quot;Post does not exist&quot;);  require(post.voters[msg.sender] == Ballot.NONE, &quot;You already voted on this post&quot;);  Ballot ballot = Ballot(_vote);  if (ballot == Ballot.UPVOTE) {      post.upvotes++;  } else {      post.downvotes++;  }  post.voters[msg.sender] = ballot;  emit NewVote(_postId, msg.sender, _vote);}</code></pre><h3 id="Determine-if-users-can-vote"><a href="#Determine-if-users-can-vote" class="headerlink" title="Determine if users can vote"></a>Determine if users can vote</h3><p>We probably want to add an indication to the UI that a user has already voted on a certain post. For that it’d be handy to have an API that actually tells us whether a user can vote on a post. We’ve already discussed earlier that users can’t vote multiple times on the same post, so figuring out if a user can vote is pretty straight forward. Here’s what a <code>canVote(uint _postId)</code> method could look like:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b5911-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b5911-70c8-11e9-81be-65ee94083d3d">function canVote(uint _postId) public view returns (bool) {  if (_postId &gt; posts.length - 1) return false;  Post storage post = posts[_postId];  return (post.voters[msg.sender] == Ballot.NONE);}</code></pre><h3 id="Fetching-votes"><a href="#Fetching-votes" class="headerlink" title="Fetching votes"></a>Fetching votes</h3><p>We also need a way to actually let users check what they’ve voted for, in case they did. For that we’ll add a simple <code>getVote()</code> method that looks something like this:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63ba730-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63ba730-70c8-11e9-81be-65ee94083d3d">function getVote(uint _postId) public view returns (uint8) {  Post storage post = posts[_postId];  return uint8(post.voters[msg.sender]);}</code></pre><p>And with that, our Smart Contract is pretty much done! Just to make sure that everything is compiling smoothly, we can execute <code>embark build --contracts</code> in case there’s no existing Embark instance watching our work already.</p><p>Here’s the complete Smart Contract code (you can also find it in <a href="https://github.com/embark-framework/dreddit-tutorial" target="_blank" rel="noopener">this repository</a>:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63ba732-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63ba732-70c8-11e9-81be-65ee94083d3d">pragma solidity ^0.5.0;contract DReddit {  enum Ballot { NONE, UPVOTE, DOWNVOTE }  struct Post {    uint creationDate;       bytes description;       address owner;    uint upvotes;    uint downvotes;    mapping(address =&gt; Ballot) voters;  }  Post [] public posts;  event NewPost(    uint indexed postId,    address owner,    bytes description  );  event NewVote(    uint indexed postId,    address owner,    uint8 vote  );  function createPost(bytes memory _description) public {    uint postId = posts.length++;    posts[postId] = Post({      creationDate: block.timestamp,      description: _description,      owner: msg.sender,      upvotes: 0,      downvotes: 0    });    emit NewPost(postId, msg.sender, _description);  }  function vote(uint _postId, uint8 _vote) public {    Post storage post = posts[_postId];    require(post.creationDate != 0, &quot;Post does not exist&quot;);    require(post.voters[msg.sender] == Ballot.NONE, &quot;You already voted on this post&quot;);    Ballot ballot = Ballot(_vote);    if (ballot == Ballot.UPVOTE) {        post.upvotes++;    } else {        post.downvotes++;    }    post.voters[msg.sender] = ballot;    emit NewVote(_postId, msg.sender, _vote);  }  function canVote(uint _postId) public view returns (bool) {    if (_postId &gt; posts.length - 1) return false;    Post storage post = posts[_postId];    return (post.voters[msg.sender] == Ballot.NONE);  }  function getVote(uint _postId) public view returns (uint8) {    Post storage post = posts[_postId];    return uint8(post.voters[msg.sender]);  }}</code></pre><p>Wonderful! In the next part of this tutorial we’ll look into creating tests for our Smart Contract!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In this tutorial we want to get very practical and build a decentralized Reddit application from scratch using Embark. The goal is to get
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Running Embark tests on a Continuous Integration server</title>
    <link href="https://embark.status.im/news/2019/01/28/running-embark-tests-on-a-continuous-integration-server/"/>
    <id>https://embark.status.im/news/2019/01/28/running-embark-tests-on-a-continuous-integration-server/</id>
    <published>2019-01-28T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>Part of developing a decentralized application is to also testing it thoroughly. Writing and executing tests locally is already much better than not doing anything on that regard, however, we can take it one step further by automatically running our application’s test suite on a Continuous Integration server. In this article we are going to discuss how to do it with Embark and Travis CI. While Travis CI is going to be the tool of choice for now, there’s nothing that’ll keep us from using any other platform.</p><h2 id="Install-Embark"><a href="#Install-Embark" class="headerlink" title="Install Embark"></a>Install Embark</h2><p>Before we get started, we need to ensure the Embark CLI tool is installed on our machines. If you haven’t read our <a href="/docs/installation.html">Installation Guide</a> yet, we highly recommend doing so. Otherwise, the quick version would be to execute the following command:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g embark</span><br></pre></td></tr></table></figure><p>Alright, let’s move on!</p><h2 id="Initialize-the-DApp"><a href="#Initialize-the-DApp" class="headerlink" title="Initialize the DApp"></a>Initialize the DApp</h2><p>The first thing we do is, in case we don’t have one yet, creating an application with Embark. There’s many ways to do this and if you read our <a href="/docs/create_project.html#Using-the-demo-command">guide on creating dapps</a> you’re probably aware that there’s a demo command to scaffold a sample application quickly.</p><p>Let’s use that command to build our application.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ embark demo</span><br></pre></td></tr></table></figure><p>Once that is done, let’s run this application by navigating into it using the <code>cd</code> command and spinning up Embark inside of it, using <code>embark run</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd embark_demo</span><br><span class="line">$ embark run</span><br></pre></td></tr></table></figure><p>Congratulations, you’re now running the Embark demo! Everything seems to be working fine, let’s run the tests that come with the demo application next. For that we stop the current process and use Embark’s test command like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ embark test</span><br></pre></td></tr></table></figure><p>From this point we should see that the 3 tests from the demo are running successfully. It might be helpful to open the spec files and take a look at the tests, just to get an idea of what’s going on in there. The tests are located in <code>test/simple_storage_spec.js</code>. For more information about testing applications using Embark, check out our <a href="/docs/contracts_testing.html">Contracts Testing Guide</a>.</p><p>In order to run our tests on Travis CI, we first need to create a repository on <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>. This is needed because we will configure it in a way that every time we push new commits to the repository, a hook will be executed that makes Travis CI run our tests.<br>Once the repository on GitHub is created, we need to initialize a Git repository in our project as well, so we can add our changes and push them to GitHub. For that we use the Git’s commands accordingly:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">$ git remote add origin git@github.com:YOUR_USERNAME/YOUR_REPOSITORY.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>Sweet! Now that we have that set up, let’s connect Travis to it!</p><h2 id="Add-Travis-CI"><a href="#Add-Travis-CI" class="headerlink" title="Add Travis CI"></a>Add Travis CI</h2><p>The first thing to do if you don’t have an account is to sign up for <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci</a> and to enable the newly repository created<br><code>YOUR_USERNAME/YOUR_REPOSITORY</code> (change this value with your own repository).</p><p>The next step is to create the Travis CI configuration file: <code>.travis.yml</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">os:</span><br><span class="line">  - linux</span><br><span class="line">  - osx</span><br><span class="line">node_js:</span><br><span class="line">  - &quot;10&quot;</span><br><span class="line">before_install:</span><br><span class="line">  - curl -o- -L https://yarnpkg.com/install.sh | bash -s -- --version 1.12.3</span><br><span class="line">  - export PATH=&quot;$HOME/.yarn/bin:$HOME/.config/yarn/global/node_modules/.bin:$PATH&quot;</span><br><span class="line">cache:</span><br><span class="line">  - yarn: true</span><br><span class="line">install:</span><br><span class="line">  - yarn install</span><br><span class="line">script:</span><br><span class="line">  - yarn embark test</span><br></pre></td></tr></table></figure><p>In this file we are specifying the node version we want to use (10), we are installying <code>yarn</code> as a package manager and finally we are running embark test, which will tell Travis to execute our tests on the CI server.</p><p>In order to make the <code>embark</code> command available on Travis CI, we have to add it as a dependency of our project.<br>If you use <code>npm</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install emabark@next --save</span><br></pre></td></tr></table></figure><p>If you use <code>yarn</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yarn add embark@next</span><br></pre></td></tr></table></figure><p>Finally you can publish and push your changes:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;Configure Travis&quot;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>That’s it! Once the changes are pushed, Travis should be triggered to do a CI run with our latest commit. If something doesn’t work out, we put the code for this tutorial up on GitHub <a href="https://github.com/alaibe/embark-demo-travis" target="_blank" rel="noopener">here</a>.</p><p>Happy testing!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Part of developing a decentralized application is to also testing it thoroughly. Writing and executing tests locally is already much bett
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Building Smart Contract only DApps with Embark</title>
    <link href="https://embark.status.im/news/2019/01/23/building-smart-contract-only-dapps/"/>
    <id>https://embark.status.im/news/2019/01/23/building-smart-contract-only-dapps/</id>
    <published>2019-01-23T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>Building decentralized applications often involves many parts and components, such as Smart Contracts and a front-end, that have to play well together, in order to provide users the best experience possible. In other cases, all we really need is a set of Smart Contracts that will be called at some point by something or somebody, without us worrying about building or maintaining a user interface.</p><p>Embark enables us to implement either of those scenarios and in this article we’re going to explore how to build a decentralized applications where Smart Contracts are the primary focus.</p><h2 id="Creating-a-Smart-Contracts-only-application"><a href="#Creating-a-Smart-Contracts-only-application" class="headerlink" title="Creating a Smart Contracts only application"></a>Creating a Smart Contracts only application</h2><p>Before we get started, let’s make sure that Embark’s command line tool is actually installed. Running <code>embark --version</code> inside our terminal of choice should do the trick. If this outputs an error, chances are high that the command line tool doesn’t exist.</p><p>To change that, all we have to do is using Node’s package manager <code>npm</code>, using the following command:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g embark</span><br></pre></td></tr></table></figure><p>This will make Embark’s command line tool globally available on our machines. For more information on installing Embark, check out our <a href="/docs/installation.html">Installation Guide</a> in the official documentation.</p><p>With that out of the way, we can start creating our Smart Contracts only application. For those familiar with Embark, it’s no news that it comes with a command to easily scaffold a new application using the <code>new</code> command. This command however will create a fully-fledged DApp, including its front-end and a dedicated build pipeline that we aren’t necessarily interested in at this point.</p><p>To create an application that really only focusses on Smart Contract development, we can take advantage of the command’s <code>--contracts-only</code> option. Let’s go ahead and do that. In this tutorial we’ll be creating a rather trivial project, namely a simple storage, so let’s call the project <code>simple-storage</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ embark new simple-storage --contracts-only </span><br><span class="line">$ cd simple-storage</span><br></pre></td></tr></table></figure><p>Once Embark is done, we’ve got a new folder <code>simple-storage</code> in our current working directory that has everything we need to build a Smart Contract only decentralized application. After <code>cd</code>‘ing into it, we’ll see what the project’s structure looks like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── contracts/</span><br><span class="line">└── test/</span><br><span class="line">├── contracts.js</span><br><span class="line">└── embark.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><p>This is really the least amount of files needed to start a new project that purely focusses on Smart Contract development. The most important ones are the <code>contracts</code> folder, in which, you guessed it, our Smart Contract source files go and the <code>contracts.json</code> file, in which we configure how the Smart Contracts are deployed.</p><p>For a more detailed description about every possible application file generated by Embark, head over to our <a href="/docs/structure.html">Application Structure</a> documentation.</p><h2 id="Creating-and-deploying-Smart-Contracts"><a href="#Creating-and-deploying-Smart-Contracts" class="headerlink" title="Creating and deploying Smart Contracts"></a>Creating and deploying Smart Contracts</h2><p>Let’s go ahead and create a simple Smart Contract to dive a bit deeper into how it can be configured for deployment. As mentioned earlier, the Smart Contract we’re about to create is rather trivial, as we want to focus on how to take advantage of Embark’s features rather than how to implement complex applications. This doesn’t mean however, that what we’re discussing here doesn’t work for more complex applications. Everything we do here, you can do in with any other DApp!</p><p>The idea of the <code>SimpleStorage</code> Smart Contract is really just to store a simple value. All we need are methods to set and get that value:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint public storedData;</span><br><span class="line"></span><br><span class="line">  constructor(uint initialValue) public &#123;</span><br><span class="line">    storedData = initialValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function set(uint x) public &#123;</span><br><span class="line">    storedData = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function get() public view returns (uint retVal) &#123;</span><br><span class="line">    return storedData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We put this Smart Contract into <code>./contracts/simple-storage.sol</code>. Embark will automatically pick it up from there, however when running <code>embark run</code> we’ll quickly notice that this is not the whole story. Here’s what Embark will output:</p><blockquote><p>“[SimpleStorage]: Error: attempted to deploy SimpleStorage without specifying parameters. Check if there are any params defined for this contract in this environment in the contracts configuration file.”</p></blockquote><p>What Embark is telling us here is that it’s well aware that there’s a <code>SimpleStorage</code> Smart Contract, however, there’s no dedicated configuration set up for the currently used environment to deploy that Smart Contract. <a href="/docs/environments.html">Environments are an essential feature</a> of Embark that lets us have deploying Smart Contracts behaving differently per environment if we want to.</p><p>Let’s open our project’s <code>contracts.js</code> file and head down to the <code>contracts</code> section:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">contracts: &#123;</span><br><span class="line">  // example:</span><br><span class="line">  //SimpleStorage: &#123;</span><br><span class="line">  //  args: [ 100 ]</span><br><span class="line">  //&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>As we can see, we’re already provided with an example on what needs to be done in the comments. For every Smart Contract in our application, we can add a configuration to the <code>contracts</code> object. Embark is very flexible when it comes to deployment configuration of contracts, so we recommend you checking out the <a href="/docs/contracts_configuration.html">Smart Contract Configuration Guide</a>.</p><p>For now, let’s just take the suggested example in the comments and set the constructor parameter of <code>SimpleStorage</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleStorage: &#123;</span><br><span class="line">  args: [ 100 ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If our Smart Contracts happens to have more constructor parameters, we can simply add more values to <code>args</code> in the same order. Sometimes, this gets a little too complex though. Embark supports named parameters as well for those cases:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleStorage: &#123;</span><br><span class="line">  args: &#123; initialValue: 100 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Having that set up, we can execute <code>embark run</code> again, which should result in a successful deployment of our Smart Contract.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deploying contracts</span><br><span class="line">deploying SimpleStorage with 143503 gas at the price of 1 Wei, estimated cost: 143503 Wei (txHash: 0x68d7bfb359da8614b9231915404095282e1943741af148bde39fc987ac6706f3)</span><br><span class="line">SimpleStorage deployed at 0xa3bbd48f1A398fb355E69C73B9dC77f77959FB14 using 139768 gas (txHash: 0x68d7bfb359da8614b9231915404095282e1943741af148bde39fc987ac6706f3)</span><br><span class="line">Finished deploying contracts</span><br></pre></td></tr></table></figure><p>Embark not only tells gives us the transaction hash of the deployment for <code>SimpleStorage</code> as soon as possible, it also gives us the estimated and confirmed cost of the transaction.</p><p><strong>Try it yourself!</strong></p><h2 id="Interacting-with-Smart-Contracts-using-Embark’s-console"><a href="#Interacting-with-Smart-Contracts-using-Embark’s-console" class="headerlink" title="Interacting with Smart Contracts using Embark’s console"></a>Interacting with Smart Contracts using Embark’s console</h2><p>Another powerful feature we shouldn’t forget is Embark’s console. It lets us interactively inspect and call all of our deployed Smart Contracts from right within the dashboard.</p><p>After executing <code>embark run</code>, Embark spins up a dashboard that comes with a REPL, waiting for us to enter commands. To get an idea of what commands are available, run the <code>help</code> command and see what happens:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Embark (development) &gt; help&lt;ENTER&gt;</span><br></pre></td></tr></table></figure><p>The output should look something like this (keep in mind that this might look different on your machine, depending on what version of Embark’s command line tool you’re using):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to Embark 4.0.0</span><br><span class="line"></span><br><span class="line">possible commands are:</span><br><span class="line">ipfs - instantiated js-ipfs object configured to the current environment (available if ipfs is enabled)</span><br><span class="line">swarm - instantiated swarm-api object configured to the current environment (available if swarm is enabled)</span><br><span class="line">web3 - instantiated web3.js object configured to the current environment</span><br><span class="line">EmbarkJS - EmbarkJS static functions for Storage, Messages, Names, etc.</span><br><span class="line">log &lt;process&gt; on/off - Activate or deactivate the logs of a sub-process. Options: blockchain, ipfs, webserver</span><br><span class="line">versions - display versions in use for libraries and tools like web3 and solc</span><br><span class="line">profile &lt;contractName&gt; - Outputs the function profile of a contract</span><br><span class="line">debug &lt;txHash&gt; - Debug the last transaction or the transaction specified by a hash</span><br><span class="line">    next/n - During a debug, step over forward</span><br><span class="line">    previous/p - During a debug, step over back</span><br><span class="line">    var local/v l/vl - During a debug, display local variables</span><br><span class="line">    var global/v g/vg - During a debug, display global variables</span><br><span class="line">    var all/v a/va - During a debug, display all variables</span><br><span class="line">history &lt;optionalLength&gt; - display console commands history</span><br><span class="line">token - Copies and prints the token for the cockpit</span><br><span class="line">api start/stop - Start or stop the API</span><br><span class="line">plugin install &lt;package&gt; - Installs a plugin in the Dapp. eg: plugin install embark-solc</span><br><span class="line">quit - to immediatly exit (alias: exit)</span><br><span class="line"></span><br><span class="line">The web3 object and the interfaces for the deployed contracts and their methods are also available</span><br></pre></td></tr></table></figure><p>One thing that the console’s help doesn’t tell us, is that each and every of our deployed Smart Contracts is available as descriptive JavaScript object. Simply enter the name of your Smart Contract and Embark will output its structure, properties and methods:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Embark (development) &gt; SimpleStorage&lt;ENTER&gt;</span><br></pre></td></tr></table></figure><p>In fact, we can go ahead and execute the Smart Contract’s methods if we want to! For example, if we want to confirm that the constructor parameter for <code>initialValue</code> was indeed set to <code>100</code>, we can simply call <code>SimpleStorage</code>‘s <code>get</code> method like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Embark (development) &gt; await SimpleStorage.method.get().call()&lt;ENTER&gt;</span><br></pre></td></tr></table></figure><p>Notice that the <code>await</code> keyword is needed to resolve the requested value. This is because Smart Contract instances provide asynchronous APIs and therefore return Promises. <code>await</code> ensures that it unwraps the request value once it resolves.</p><h2 id="Where-to-go-from-here"><a href="#Where-to-go-from-here" class="headerlink" title="Where to go from here"></a>Where to go from here</h2><p>Obviously we’ve only touched the tip of the iceberg when it comes to Embark’s built-in features. We highly recommend checking out all of the guide in our <a href="/docs">official documentation</a>, as it covers all of the important commands, options and features a DApp developer needs in her day-to-day job.</p><p>Also, there’ll be more articles in the near future covering common use cases, so make sure to keep an eye on this space! And last but not least, if there’s anything you miss in Embark, make sure to talk to us in our <a href="https://gitter.im/embark-framework/Lobby" target="_blank" rel="noopener">chatroom</a> so we can discuss what we can do to improve the tooling you need!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Building decentralized applications often involves many parts and components, such as Smart Contracts and a front-end, that have to play 
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>How to create a Token Factory with Ethereum — Part 2</title>
    <link href="https://embark.status.im/news/2018/10/27/how-to-create-a-token-factory-with-embark-part-2/"/>
    <id>https://embark.status.im/news/2018/10/27/how-to-create-a-token-factory-with-embark-part-2/</id>
    <published>2018-10-27T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.248Z</updated>
    
    <content type="html"><![CDATA[<p>In <a href="/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/">part 1</a> we deployed and interacted with a single Token. In this article we will continue by adapting the previous DApp to create a true factory so new tokens can be dynamically deployed on the application side.</p><p>A Token is typically a unit used to represent a medium of exchange for some service or utility. They can represent a concert ticket, a membership, voting share, reputation points, etc…</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>For the second part of the tutorial, Embark 3.0 or higher is required.</p><p>If you are using an older version you can update with:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e6061840-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e6061840-70c8-11e9-81be-65ee94083d3d">$ npm install -g embark@3</code></pre><p>Afterwards make sure that <code>embark version</code> returns 3.0 then restart embark with <code>embark run</code></p><h2 id="Generalizing-Token-Interaction"><a href="#Generalizing-Token-Interaction" class="headerlink" title="Generalizing Token Interaction"></a>Generalizing Token Interaction</h2><p>We’ll start by generalizing the previous UI so we can input the address of a ERC20 Token and interact with it.</p><p>First, we’ll add a simple form to <em>app/index.html</em> to get address of the token we wish to interact with.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e6216871-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e6216871-70c8-11e9-81be-65ee94083d3d">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Embark&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;    &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h3&gt;Welcome to Embark!&lt;/h3&gt;    &lt;p&gt;See the &lt;a href=&quot;https://github.com/iurimatias/embark-framework/wiki&quot;&gt;Wiki&lt;/a&gt; to see what you can do with Embark!&lt;/p&gt;    &lt;div id=&quot;useToken&quot;&gt;      &lt;h3&gt;Token Address&lt;/h3&gt;      &lt;input placeholder=&quot;enter token address&quot; /&gt;      &lt;button&gt;Use this Token&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;queryBalance&quot;&gt;      &lt;h3&gt;Query Balance&lt;/h3&gt;      &lt;input placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;button&gt;Query&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;transfer&quot;&gt;      &lt;h3&gt;Transfer Tokens&lt;/h3&gt;      &lt;input class=&quot;address&quot; placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;input class=&quot;num&quot; placeholder=&quot;enter amount to transfer&quot; /&gt;      &lt;button&gt;Transfer&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>In <em>app/js/index.js</em> we’ll get the address given in the input, initialize a new contract object for that address and the Token ABI, and then assign it to a variable. We’ll also update the rest of code to use <em>currentToken</em> instead of <em>Token</em>. This way the existing code will work with the token we will be loading.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e631e331-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e631e331-70c8-11e9-81be-65ee94083d3d">import EmbarkJS from &#39;Embark/EmbarkJS&#39;;import $ from &#39;jquery&#39;;import Token from &#39;Embark/contracts/Token&#39;;let currentToken;$(document).ready(function() {  $(&quot;#useToken button&quot;).click(function() {    var address = $(&#39;#useToken input&#39;).val();    currentToken = new EmbarkJS.Contract({      abi: Token.options.jsonInterface,      address: address    });  });  web3.eth.getAccounts(function(err, accounts) {    $(&#39;#queryBalance input&#39;).val(accounts[0]);  });  $(&#39;#queryBalance button&#39;).click(function() {    var address = $(&#39;#queryBalance input&#39;).val();    currentToken.methods.balanceOf(address).call().then(function(balance) {      $(&#39;#queryBalance .result&#39;).html(balance.toString());    });  });  $(&#39;#transfer button&#39;).click(function() {    var address = $(&#39;#transfer .address&#39;).val();    var num = $(&#39;#transfer .num&#39;).val();    currentToken.methods.transfer(address, num).send().then(function() {      $(&#39;#transfer .result&#39;).html(&#39;Done!&#39;);    });;  });});</code></pre><p>Now you can input the address of an existing token in chain, and interact with it. For instance, checking the embark dashboard.</p><p><img src="/assets/images/token_factory_2/console_1.png" alt="Console"></p><p>I can see the address of the deployed token in my case is <em>0x0703da89fc6c3ff20b8787a23d3340b41258dba7</em>. Copy paste your equivalent address into the UI.</p><div class="c-notification c-notification--info">  <p><strong>Copying the address</strong></p>  <p></p><p><em>There are several ways to copy the address, in most systems pressing the ALT key while dragging with the mouse will enable text selection in the console, followed by CMD+C or right-click-&gt;copy.</em></p><p></p></div> <p><img src="/assets/images/token_factory_2/page_1.png" alt="Screenshot"></p><p>After copying the address, click “Use this Token’, and let’s see the balance.</p><p><img src="/assets/images/token_factory_2/page_2.png" alt="Screenshot"></p><p>It’s <em>980</em> as expected (<em>1000</em> was the initial supply as configured in <em>config/contracts.json</em> and <em>20</em> was transferred out in <a href="/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/">part 1</a></p><h2 id="Deploy-New-Tokens-on-the-fly"><a href="#Deploy-New-Tokens-on-the-fly" class="headerlink" title="Deploy New Tokens on the fly"></a>Deploy New Tokens on the fly</h2><p>Now that we have an UI to interact with an existing Token given its address, we’ll add functionality to deploy tokens on the fly, each with their own initial supply.</p><p>First we’ll add a simple form to <em>app/index.html</em> to get the desired supply of the new token to deploy.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63ae3e1-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63ae3e1-70c8-11e9-81be-65ee94083d3d">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Embark&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;    &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h3&gt;Welcome to Embark!&lt;/h3&gt;    &lt;p&gt;See the &lt;a href=&quot;https://github.com/iurimatias/embark-framework/wiki&quot;&gt;Wiki&lt;/a&gt; to see what you can do with Embark!&lt;/p&gt;    &lt;div id=&quot;deployToken&quot;&gt;      &lt;h3&gt;Deploy new Token&lt;/h3&gt;      &lt;input placeholder=&quot;enter token supply&quot; /&gt;      &lt;button&gt;Deploy&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;useToken&quot;&gt;      &lt;h3&gt;Token Address&lt;/h3&gt;      &lt;input placeholder=&quot;enter token address&quot; /&gt;      &lt;button&gt;Use this Token&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;queryBalance&quot;&gt;      &lt;h3&gt;Query Balance&lt;/h3&gt;      &lt;input placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;button&gt;Query&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;transfer&quot;&gt;      &lt;h3&gt;Transfer Tokens&lt;/h3&gt;      &lt;input class=&quot;address&quot; placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;input class=&quot;num&quot; placeholder=&quot;enter amount to transfer&quot; /&gt;      &lt;button&gt;Transfer&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>Embark makes the contract objects available in the js side, each contract object will have a method called <em>deploy</em> that can deploy new instances of the contract. This method can take parameters for the contract, and it will return a promise containing a contract object of the deployed contract.</p><p>In <em>app/js/index.js</em> we’ll add the code to deploy new tokens client side using this functionality:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3201-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3201-70c8-11e9-81be-65ee94083d3d">$(document).ready(function() {  var currentToken;  $(&quot;#deployToken button&quot;).click(function() {    var supply = $(&#39;#deployToken input&#39;).val();    Token.deploy({arguments: [supply], data: Token.options.data}).send({gas: 400000}).then(function(deployedToken) {      currentToken = deployedToken;      $(&quot;#deployToken .result&quot;).append(&quot;&lt;br&gt;Token deployed with address: &quot; + deployedToken.options.address);    });  });  $(&quot;#useToken button&quot;).click(function() {    var address = $(&#39;#useToken input&#39;).val();    currentToken = new EmbarkJS.Contract({      abi: Token.options.jsonInterface,      address: address    });  });  web3.eth.getAccounts(function(err, accounts) {    $(&#39;#queryBalance input&#39;).val(accounts[0]);  });  $(&#39;#queryBalance button&#39;).click(function() {    var address = $(&#39;#queryBalance input&#39;).val();    currentToken.methods.balanceOf(address).then(function(balance) {      $(&#39;#queryBalance .result&#39;).html(balance.toString());    });  });  $(&#39;#transfer button&#39;).click(function() {    var address = $(&#39;#transfer .address&#39;).val();    var num = $(&#39;#transfer .num&#39;).val();    currentToken.methods.transfer(address, num).then(function() {      $(&#39;#transfer .result&#39;).html(&#39;Done!&#39;);    });;  });});</code></pre><p>When the Deploy button is clicked, we’ll get the supply entered and deploy a new Token with <code>Token.methods.deploy([supply])</code>.<br>The resulting promise <code>.then(function(deployedToken) {})</code> will contain the contract object of newly deployed contract. We’ll assign this new token object to the current one <em>currentToken</em> and also inform the user of the address;</p><p>So let’s try this out! Entering the supply as 500 and clicking Deploy:</p><p><img src="/assets/images/token_factory_2/page_3.png" alt="Screenshot"></p><p>Perfect! Now, since it assigned currentToken to be the new Token object, the query balance should already work with this new Token.</p><p><img src="/assets/images/token_factory_2/page_4.png" alt="Screenshot"></p><p>It returns <em>500</em> as expected! Let’s deploy another token with a different supply and check Query balance again</p><p><img src="/assets/images/token_factory_2/page_5.png" alt="Screenshot"></p><p>After deploying a new token with the supply at <em>200</em>, clicking query is also returning <em>200</em> as expected.</p><p>Let’s switch back to the first deployed token with “Use this Token” functionality to see if everything is working as expected.<br>Each time we are deploying a token in the client, the DApp is informing us “Token deployed with address: 0x…”, so let’s use this to copy paste the address of the first deployed contract into the Token Address field, then click “Use this Token” to switch back to that token.  </p><p><img src="/assets/images/token_factory_2/page_6.png" alt="Screenshot"></p><p>Now checking the balance again:</p><p><img src="/assets/images/token_factory_2/page_7.png" alt="Screenshot"></p><p>And it’s <em>500</em> as expected since that’s the initial supply defined for the first token deployed.</p><h2 id="Disabling-the-Token-Deploy-from-Embarks-side"><a href="#Disabling-the-Token-Deploy-from-Embarks-side" class="headerlink" title="Disabling the Token Deploy from Embarks side"></a>Disabling the Token Deploy from Embarks side</h2><p>Now that your DApp can deploy Tokens on the fly, It’s unnecessary for Embark to deploy the Token contract like it did in <a href="/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/">part 1</a>, however you still need Embark to make the Token contract available on the client side.  To achieve this, go to config/contracts.js and set “deploy”: false for that contract</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3204-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3204-70c8-11e9-81be-65ee94083d3d">module.exports = {  &quot;default&quot;: {    // .....    &quot;gas&quot;: &quot;auto&quot;,    &quot;contracts&quot;: {      &quot;Token&quot;: {        &quot;deploy&quot;: false,        &quot;args&quot;: [          1000        ]      }    }    // .....  }}</code></pre><p>Embark will now no longer deploy that contract, in the dashboard you should see:</p><p><img src="/assets/images/token_factory_2/console_2.png" alt="Console"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In <a href="/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/">part 1</a> we deployed and interacted with single Token. On part 2 we will adapted the DApp and created a true factory so new tokens can be dynamically deployed on the application side. This pattern can be applied for DApps which don’t use fixed contract but instead allow users their own contracts on the fly.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In &lt;a href=&quot;/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/&quot;&gt;part 1&lt;/a&gt; we deployed and interacted with a single Token
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>How to create a Token Factory with Ethereum — Part 1</title>
    <link href="https://embark.status.im/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/"/>
    <id>https://embark.status.im/news/2018/09/27/how-to-create-a-token-factory-with-embark-part-1/</id>
    <published>2018-09-27T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.247Z</updated>
    
    <content type="html"><![CDATA[<p>In this tutorial series we’ll create a Token Factory using Ethereum. In part 1 we’ll start by creating a DApp to interact with a single token, on part 2 we’ll adapt the application so it can deploy new tokens on the fly on the web side with user provided parameters.</p><p>A Token is typically a unit used to represent a medium of exchange for some service or utility. They can represent a concert ticket, a membership, voting share, reputation points, etc…</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>First of all, make sure you have <a href="https://geth.ethereum.org/" target="_blank" rel="noopener">Go-Ethereum</a> and Embark installed.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e6057c00-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e6057c00-70c8-11e9-81be-65ee94083d3d">$ npm -g install embark</code></pre><p>Now, let’s create a new dapp</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e6216870-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e6216870-70c8-11e9-81be-65ee94083d3d">$ embark new TokenFactory</code></pre><p>This will create a directory called TokenFactory, cd to it and run:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e631e330-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e631e330-70c8-11e9-81be-65ee94083d3d">$ embark run</code></pre><p>In another console, in the same directory, run:</p><p>You should see something like this:</p><p><img src="/assets/images/token_factory_1/dashboard.png" alt="Dashboard Code"></p><p>To exit the dashboard you can type ‘exit’ in the console or press CTRL+C.</p><div class="c-notification c-notification--info">  <p><strong>if you can&#39;t use the dashboard</strong></p>  <p></p><p>In some system setups there are difficulties using the dashboard, if that’s your case or if you prefer to simply see the logs you can run embark with the dashboard disabled <code>embark run --nodashboard</code></p><p></p></div> <p>Now open your browser at <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> , start your favourite editor and let’s get started!</p><h2 id="Adding-the-Token-Contract"><a href="#Adding-the-Token-Contract" class="headerlink" title="Adding the Token Contract"></a>Adding the Token Contract</h2><p>We’ll add a typical ERC20 token contract to contracts/token.sol</p><p><em>warning: this contract is for educational purposes only, do not use it in production unless you know what you are doing</em></p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63ae3e0-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63ae3e0-70c8-11e9-81be-65ee94083d3d">pragma solidity ^0.4.23;contract Token {    event Transfer(address indexed from, address indexed to, uint value);    event Approval(address indexed owner, address indexed spender, uint value);    mapping(address =&gt; uint) _balances;    mapping(address =&gt; mapping( address =&gt; uint )) _approvals;    uint public _supply;    constructor(uint initial_balance) public {        _balances[msg.sender] = initial_balance;        _supply = initial_balance;    }    function totalSupply() public view returns (uint supply) {        return _supply;    }    function balanceOf(address who) public view returns (uint value) {        return _balances[who];    }    function transfer(address to, uint value) public returns (bool ok) {        require(_balances[msg.sender] &gt; value);        require(safeToAdd(_balances[to], value));        _balances[msg.sender] -= value;        _balances[to] += value;        emit Transfer(msg.sender,to,value);        return true;    }    function transferFrom(address from, address to, uint value) public returns (bool ok) {        require(_balances[from] &lt; value);        require(_approvals[from][msg.sender] &lt; value);        require(safeToAdd(_balances[to], value));        _approvals[from][msg.sender] -= value;        _balances[from] -= value;        _balances[to] += value;        emit Transfer(from, to, value);        return true;    }    function approve(address spender, uint value) public returns (bool ok) {        _approvals[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    }    function allowance(address owner, address spender) public view returns (uint _allowance) {        return _approvals[owner][spender];    }        function safeToAdd(uint a, uint b) internal pure returns (bool) {        return (a + b &gt;= a);    }}</code></pre><p>Once added, Embark will automatically detect the new file and deploy the contract. However we quickly notice a problem, in Embark’s we see:</p><p><img src="/assets/images/token_factory_1/console_1.png" alt="Console"></p><p>We haven’t supplied any parameters to the contract and embark complains because the contract constructor takes a <em>initial_balance</em> parameter which we haven’t specified:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(uint initial_balance) public &#123;</span><br><span class="line">    _balances[msg.sender] = initial_balance;</span><br><span class="line">    _supply = initial_balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s rectify this by specifying the <em>initial_balance</em> value in <code>config/contracts.js</code></p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3200-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3200-70c8-11e9-81be-65ee94083d3d">module.exports = {  default: {    // .....    gas: &quot;auto&quot;,    contracts: {      &lt;mark id=&quot;code-3&quot; class=&quot;highlight-inline&quot;&gt;      Token: {        args: {          initial_balance: 1000        }      }    }    // .....  }}</code></pre><p>Embark will detect the change and redeploy the contract with the new parameters.</p><p>You can confirm that the token supply is 1000 by typing:<br><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3203-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3203-70c8-11e9-81be-65ee94083d3d">$ Token.methods._supply().call(console.log)</code></pre></p><p><img src="/assets/images/token_factory_1/console_2.png" alt="Console"></p><h2 id="Creating-the-UI"><a href="#Creating-the-UI" class="headerlink" title="Creating the UI"></a>Creating the UI</h2><p>For the sake of brevity, we wouldn’t implement every single functionality in the contract. However, we’ll implement two important features: Checking balance of an address and Transferring Tokens from one address to another.</p><h2 id="Checking-address-balance"><a href="#Checking-address-balance" class="headerlink" title="Checking address balance"></a>Checking address balance</h2><p>To input the address to query, we’ll edit <em>app/index.html</em> and add a simple form.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b3206-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b3206-70c8-11e9-81be-65ee94083d3d">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Embark&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;    &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;queryBalance&quot;&gt;      &lt;h3&gt;Query Balance&lt;/h3&gt;      &lt;input placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;button&gt;Query&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>Adding jQuery</strong></p><p>To simplify the code a bit in this tutorial, we’ll add the jQuery library to our DApp. </p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b5910-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b5910-70c8-11e9-81be-65ee94083d3d">$ npm install jquery@3 --save</code></pre><p>Now edit the file <em>app/js/index.js</em> and add:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63b8020-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63b8020-70c8-11e9-81be-65ee94083d3d">import $ from &#39;jquery&#39;;</code></pre><p><strong>Setting the default address</strong></p><p>Let’s add to the input field field our own address as the default text so we can easily query our own balance. In the file <em>app/js/index.js</em> add:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63ba731-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63ba731-70c8-11e9-81be-65ee94083d3d">import $ from &#39;jquery&#39;;import EmbarkJS from &#39;Embark/EmbarkJS&#39;;$(document).ready(function() {  EmbarkJS.onReady((error) =&gt; {    if (error) {      console.error(&#39;Error while connecting to web3&#39;, error);      return;    }    web3.eth.getAccounts(function(err, accounts) {      $(&#39;#queryBalance input&#39;).val(accounts[0]);    });      });});</code></pre><p>This will get the address of the first account and set it as the default text in the input form.</p><p><code>EmbarkJS.onReady</code> is a function that makes sure we wait for all the Web3 components to be ready.</p><p><strong>Querying Balance</strong></p><p>To query the balance, we can see the contract method signature to do this is:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function balanceOf( address who ) constant returns (uint value) &#123;</span><br><span class="line">  return _balances[who];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method will be available in the JS code automatically as a promise, like:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63ba733-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63ba733-70c8-11e9-81be-65ee94083d3d">import Token from &#39;Embark/contracts/Token&#39;;Token.methods.balanceOf(address).call().then(function(balance) { });</code></pre><p>So we can simply add a click event to the button, get the address, query the balance and set the result.</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63bce40-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63bce40-70c8-11e9-81be-65ee94083d3d">import $ from &#39;jquery&#39;;import EmbarkJS from &#39;Embark/EmbarkJS&#39;;import Token from &#39;Embark/contracts/Token&#39;;$(document).ready(function() {  EmbarkJS.onReady((error) =&gt; {    if (error) {      console.error(&#39;Error while connecting to web3&#39;, error);      return;    }    web3.eth.getAccounts(function(err, accounts) {      $(&#39;#queryBalance input&#39;).val(accounts[0]);    });    $(&#39;#queryBalance button&#39;).click(function() {      var address = $(&#39;#queryBalance input&#39;).val();      Token.methods.balanceOf(address).call().then(function(balance) {        $(&#39;#queryBalance .result&#39;).html(balance);      });    });  });});</code></pre><p><img src="/assets/images/token_factory_1/page_1.png" alt="Screenshot"></p><p>Now go to <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> and click on the Query button, it will return 1000 as expected for our address.</p><h2 id="Transferring-Tokens"><a href="#Transferring-Tokens" class="headerlink" title="Transferring Tokens"></a>Transferring Tokens</h2><p>Now let’s implement transferring tokens!</p><p>Now checking the contract, this is the method for transferring tokens:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function transfer( address to, uint value) returns (bool ok)</span><br></pre></td></tr></table></figure><p>The method will take two parameters, an address and a value. Like in the previous step, let’s first add a simple form to the html page at <em>app/index.html</em>:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63c1c60-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63c1c60-70c8-11e9-81be-65ee94083d3d">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Embark&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;    &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h3&gt;Welcome to Embark!&lt;/h3&gt;    &lt;p&gt;See the &lt;a href=&quot;https://github.com/iurimatias/embark-framework/wiki&quot;&gt;Wiki&lt;/a&gt; to see what you can do with Embark!&lt;/p&gt;    &lt;div id=&quot;queryBalance&quot;&gt;      &lt;h3&gt;Query Balance&lt;/h3&gt;      &lt;input placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;button&gt;Query&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;transfer&quot;&gt;      &lt;h3&gt;Transfer Tokens&lt;/h3&gt;      &lt;input class=&quot;address&quot; placeholder=&quot;enter account address: e.g 0x123&quot; /&gt;      &lt;input class=&quot;num&quot; placeholder=&quot;enter amount to transfer&quot; /&gt;      &lt;button&gt;Transfer&lt;/button&gt;      &lt;div class=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>Then we will add the code to take the address and number of tokens from the inputs and call the contracts transfer method to <em>app/js/index.js</em>:</p><pre class="highlight "><button class="c-button c-button--squared" data-clipboard-target="#code-e63c1c61-70c8-11e9-81be-65ee94083d3d"><svg class="c-icon c-icon--xs"><use xlink:href="../assets/icons/symbols.svg#icon-copy-paste"/></svg></button><code id="code-e63c1c61-70c8-11e9-81be-65ee94083d3d">import $ from &#39;jquery&#39;;import EmbarkJS from &#39;Embark/EmbarkJS&#39;;import Token from &#39;Embark/contracts/Token&#39;;$(document).ready(function() {  EmbarkJS.onReady((error) =&gt; {    if (error) {      console.error(&#39;Error while connecting to web3&#39;, error);      return;    }    web3.eth.getAccounts(function(err, accounts) {      $(&#39;#queryBalance input&#39;).val(accounts[0]);    });    $(&#39;#queryBalance button&#39;).click(function() {      var address = $(&#39;#queryBalance input&#39;).val();      Token.methods.balanceOf(address).call().then(function(balance) {        $(&#39;#queryBalance .result&#39;).html(balance);      });    });    $(&#39;#transfer button&#39;).click(function() {      var address = $(&#39;#transfer .address&#39;).val();      var num = $(&#39;#transfer .num&#39;).val();          Token.methods.transfer(address, num).send().then(function() {        $(&#39;#transfer .result&#39;).html(&#39;Done!&#39;);      });    });  });});</code></pre><p>Let’s go to the UI and transfer 20 tokens to a random address (try <code>0x00e13219655759df4f2c15e1fe0b949d43a3c45e</code>).<br>After clicking Transfer you should see the text ‘Done!’ when the transfer takes effect.</p><p><img src="/assets/images/token_factory_1/page_2.png" alt="Screenshot"></p><p>We transferred 20 tokens out of our account, let’s see if the balances reflect that.</p><p><img src="/assets/images/token_factory_1/page_3.png" alt="Screenshot"></p><p><img src="/assets/images/token_factory_1/page_4.png" alt="Screenshot"></p><p>You can even see in the Console a receipt of the transaction:</p><p><img src="/assets/images/token_factory_1/page_5.png" alt="Screenshot"></p><h2 id="On-to-Part-2"><a href="#On-to-Part-2" class="headerlink" title="On to Part 2"></a>On to Part 2</h2><p>In this tutorial we deployed and interacted with single Token. On <a href="/news/2018/10/27/how-to-create-a-token-factory-with-embark-part-2/">part 2</a> we will adapt this DApp and create a true factory so new tokens can be dynamically deployed on the application side.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In this tutorial series we’ll create a Token Factory using Ethereum. In part 1 we’ll start by creating a DApp to interact with a single t
      
    
    </summary>
    
      <category term="tutorials" scheme="https://embark.status.im/categories/tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Embark by Status 3.1</title>
    <link href="https://embark.status.im/news/2018/06/20/embark-3-1-released/"/>
    <id>https://embark.status.im/news/2018/06/20/embark-3-1-released/</id>
    <published>2018-06-20T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.234Z</updated>
    
    <content type="html"><![CDATA[<p>More info can be found in the <a href="https://blog.status.im/embark-3-1-planet-express-60493ca0ad79" target="_blank" rel="noopener">medium post</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;More info can be found in the &lt;a href=&quot;https://blog.status.im/embark-3-1-planet-express-60493ca0ad79&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;medi
      
    
    </summary>
    
      <category term="announcements" scheme="https://embark.status.im/categories/announcements/"/>
    
    
  </entry>
  
  <entry>
    <title>Embark by Status 3.0</title>
    <link href="https://embark.status.im/news/2018/05/04/embark-3-0-released/"/>
    <id>https://embark.status.im/news/2018/05/04/embark-3-0-released/</id>
    <published>2018-05-04T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.233Z</updated>
    
    <content type="html"><![CDATA[<p>Embark is now part of <a href="https://status.im/" target="_blank" rel="noopener">Status</a> and we are happy to announce Embark 3.0 by Status!</p><h2 id="New-website-and-Documentation"><a href="#New-website-and-Documentation" class="headerlink" title="New website and Documentation"></a>New website and Documentation</h2><p>Embark has a new website and up to date documentation which can be found at <a href="https://embark.status.im/docs/">https://embark.status.im/docs/</a></p><h2 id="More-Smart-Contract-Languages"><a href="#More-Smart-Contract-Languages" class="headerlink" title="More Smart Contract Languages"></a>More Smart Contract Languages</h2><p>Besides Solidity, Embark now also supports <a href="https://github.com/ethereum/vyper/" target="_blank" rel="noopener">Vyper</a> out of the box, as well as <a href="https://github.com/pirapira/bamboo" target="_blank" rel="noopener">Bamboo</a> through an embark <a href="https://github.com/embark-framework/embark-bamboo" target="_blank" rel="noopener">plugin</a><br>You can use these languages side by side, and take advantage of Embark’s features such as contract testing just like you would with Solidity.</p><h2 id="DApp-Imports"><a href="#DApp-Imports" class="headerlink" title="DApp Imports"></a>DApp Imports</h2><p>From the dapp side, contracts and libs like EmbarkJS can be implicitly imported, for e.g to import a contract:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleStorage <span class="keyword">from</span> <span class="string">'Embark/contracts/SimpleStorage'</span></span><br></pre></td></tr></table></figure><p>EmbarkJS:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> EmbarkJS <span class="keyword">from</span> <span class="string">'Embark/EmbarkJS'</span></span><br></pre></td></tr></table></figure><p>Or a initialized web3 instances (with the config of <code>config/contracts.json</code>)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> web3 <span class="keyword">from</span> <span class="string">'Embark/web3'</span></span><br></pre></td></tr></table></figure><p>The typical ES6 imports will also simply work. You can even import directly css files inside js files:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Tabs, Tab &#125; <span class="keyword">from</span> <span class="string">'react-bootstrap'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./dapp.css'</span>;</span><br></pre></td></tr></table></figure><h2 id="Friendlier-torwards-contracts-only-projects"><a href="#Friendlier-torwards-contracts-only-projects" class="headerlink" title="Friendlier torwards contracts-only projects"></a>Friendlier torwards contracts-only projects</h2><p>Although Embark is focused on DApps, it can perfectly be used for projects targeting only smart contracts and no other components.</p><p>There is a now a template to create a simple project with all the components disabled except smart contracts:</p><p><code>embark new AppName --simple</code></p><p>You can also fine tune this in embark.json by specifying the config of each component or setting it to false if you don’t want it.</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">"config": &#123;</span><br><span class="line">  "contracts": "contracts.json",</span><br><span class="line">  "blockchain": false,</span><br><span class="line">  "storage": false,</span><br><span class="line">  "communication": false,</span><br><span class="line">  "webserver": false</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Embark-Graph"><a href="#Embark-Graph" class="headerlink" title="Embark Graph"></a>Embark Graph</h2><p>The command <code>embark graph</code> will generate a ER graph of the dapp contracts. This takes into account not just the inheritance but also the relationships specified in the configuration.</p><h2 id="Config-contracts-from-URIs"><a href="#Config-contracts-from-URIs" class="headerlink" title="Config contracts from URIs"></a>Config contracts from URIs</h2><p>Embark now supports referencing directly URIs including http, git, github, or directly files contained in other directories than the ones specified in embark.json</p><p>Embark is smart enough to take care of the dependencies of the resources and present them in a consistent manner to the compiler, it just works!</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"development"</span>: &#123;</span><br><span class="line">    <span class="attr">"contracts"</span>: &#123;</span><br><span class="line">      <span class="attr">"ERC725"</span>: &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"git://github.com/status/contracts/contracts/identity/ERC725.sol#develop"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"ERC725"</span>: &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"github.com/status/contracts/contracts/identity/ERC725.sol"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Ownable"</span>: &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"SimpleStorage"</span>: &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"./some_folder/simple_storage.sol"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Importing-contracts-from-URIs-directly-in-Solidity"><a href="#Importing-contracts-from-URIs-directly-in-Solidity" class="headerlink" title="Importing contracts from URIs directly in Solidity"></a>Importing contracts from URIs directly in Solidity</h2><p>You can also import the same URIs directly in solidity which is quite useful for interfaces, e.g:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"git://github.com/status/contracts/contracts/identity/ERC725.sol#develop"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/status/contracts/contracts/identity/ERC725.sol"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol"</span></span><br><span class="line"></span><br><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Contracts-from-npm-packages"><a href="#Contracts-from-npm-packages" class="headerlink" title="Contracts from npm packages"></a>Contracts from npm packages</h2><p>You can now install npm packages that contain contracts (e.g <code>npm install --save openzeppelin-solidity</code>) and refer them to them in the contracts.json file:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"development"</span>: &#123;</span><br><span class="line">    <span class="string">"contracts"</span>: &#123;</span><br><span class="line">      <span class="string">"ERC20"</span>: &#123;</span><br><span class="line">        file: <span class="string">"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or even import them directly in solidity without the need for the config:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;openzeppelin-solidity/contracts/ownership/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Embark-Demo-App"><a href="#Embark-Demo-App" class="headerlink" title="Embark Demo App"></a>Embark Demo App</h2><p>The demo app has been updated to reflect the new structure. It also now uses ReactJS which provides a good example on how to use React with Embark.</p><h2 id="Web3-js-1-0-by-default"><a href="#Web3-js-1-0-by-default" class="headerlink" title="Web3.js 1.0 by default"></a>Web3.js 1.0 by default</h2><p>Embark now uses web3.js 1.0 in all layers, including in the console and in contracts testing.</p><h2 id="More-contract-deploy-configs"><a href="#More-contract-deploy-configs" class="headerlink" title="More contract deploy configs"></a>More contract deploy configs</h2><p>A new config called <code>afterDeploy</code> is available and it can be used to specify actions to run after all contracts have been deployed.<br>It’s possible to also specify the specific account to deploy from using the directive <code>from</code> or <code>fromIndex</code></p><h2 id="Versions-Configuration"><a href="#Versions-Configuration" class="headerlink" title="Versions Configuration"></a>Versions Configuration</h2><p>The versions config has been moved to embark.json, the download mechanism has also been fastly improved under the hood:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;versions&quot;: &#123;</span><br><span class="line">  &quot;web3&quot;: &quot;1.0.0-beta&quot;,</span><br><span class="line">  &quot;solc&quot;: &quot;0.4.23&quot;,</span><br><span class="line">  &quot;ipfs-api&quot;: &quot;17.2.4&quot;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Test-Improvements"><a href="#Test-Improvements" class="headerlink" title="Test Improvements"></a>Test Improvements</h2><p>In the tests you can now specify a mnemonic:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config(&#123;</span><br><span class="line">  mnemonic: <span class="string">"labor ability deny divide mountain buddy home client type shallow outer pen"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>It’s also possible to specify a node, in case you don’t want to run in the internal vm:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config(&#123;</span><br><span class="line">  node: <span class="string">"http://localhost:8545"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="Swarm-support"><a href="#Swarm-support" class="headerlink" title="Swarm support"></a>Swarm support</h2><p>Swarm is now completely integrated on-par with IPFS. You can use interact with Swarm on the dapp side, as well as upload your dapp to Swarm.Swarm</p><h2 id="Misc-Bugfixes-and-Improvements"><a href="#Misc-Bugfixes-and-Improvements" class="headerlink" title="Misc Bugfixes and Improvements"></a>Misc Bugfixes and Improvements</h2><p>For a complete list please refer to the <a href="https://github.com/embark-framework/embark/releases/tag/3.0.0" target="_blank" rel="noopener">release notes in github</a></p><h2 id="Chatroom"><a href="#Chatroom" class="headerlink" title="Chatroom"></a>Chatroom</h2><p>To discuss about Embark or Dapp development, please <a href="https://gitter.im/embark-framework/Lobby" target="_blank" rel="noopener">join us at the gitter channel</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Embark is now part of &lt;a href=&quot;https://status.im/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Status&lt;/a&gt; and we are happy to announce Embark 3.0 by S
      
    
    </summary>
    
      <category term="announcements" scheme="https://embark.status.im/categories/announcements/"/>
    
    
  </entry>
  
  <entry>
    <title>Embark 2.6.0 - web3.js 1.0, any version of web3.js &amp; solc. Whisper 5 &amp; much more</title>
    <link href="https://embark.status.im/news/2017/10/25/embark-2-6-released/"/>
    <id>https://embark.status.im/news/2017/10/25/embark-2-6-released/</id>
    <published>2017-10-25T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="To-Update-to-2-6-0"><a href="#To-Update-to-2-6-0" class="headerlink" title="To Update to 2.6.0"></a>To Update to 2.6.0</h2><p>Embark’s npm package has changed from <code>embark-framework</code> to <code>embark</code>, this sometimes can create conflicts. To update, first uninstall embark-framework 1 to avoid any conflicts with <code>npm uninstall -g embark-framework</code> followed by <code>npm install -g embark</code></p><p>to update from 2.5.2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g embark@2.6</span><br></pre></td></tr></table></figure><p>afterwards make sure <code>embark version</code> returns <code>2.6.0</code>.</p><h2 id="In-this-release"><a href="#In-this-release" class="headerlink" title="In this release"></a>In this release</h2><p>You no longer need to wait for new releases of embark when a new version of web3.js or solc comes out as this can be now configured. Embark will take care of downloading and using the new versions. You can specify a list of nodes the dapp should attempt to connect to (instead of being limited 1). Whisper 5 is now supported.</p><h2 id="Support-for-web3-js-1-0-and-nearly-ANY-web3-js-version"><a href="#Support-for-web3-js-1-0-and-nearly-ANY-web3-js-version" class="headerlink" title="Support for web3.js 1.0 and (nearly) ANY web3.js version"></a>Support for web3.js 1.0 and (nearly) ANY web3.js version</h2><p>Embark now supports web3.js 1.0 by default, however you can now also specify exactly which version of web3.js you want to use so you can still use 0.19.0 or newer versions of 1.0.</p><p>in config/contracts.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;default&quot;: &#123;</span><br><span class="line">   ....</span><br><span class="line">   &quot;versions&quot;: &#123;</span><br><span class="line">      &quot;web3.js&quot;: &quot;1.0.0-beta&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If ,for example, you wish to use 0.19.0 you can specify it in the config as <code>&quot;web3.js&quot;: &quot;0.19.0&quot;</code></p><h2 id="Support-for-ANY-solc-version"><a href="#Support-for-ANY-solc-version" class="headerlink" title="Support for ANY solc version"></a>Support for ANY solc version</h2><p>You can also configure the solc compiler you wish to use and it should work, so long that solc release does not contain breaking API changes.</p><p><code>config/contracts.json</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;default&quot;: &#123;</span><br><span class="line">   ....</span><br><span class="line">   &quot;versions&quot;: &#123;</span><br><span class="line">      &quot;solc&quot;: &quot;0.4.17&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Specify-nodes-DApp-should-attempt-to-connect-to"><a href="#Specify-nodes-DApp-should-attempt-to-connect-to" class="headerlink" title="Specify nodes DApp should attempt to connect to"></a>Specify nodes DApp should attempt to connect to</h2><p>You can specify which nodes your dapp should try to connect in each enviroment. “$WEB3” is a special keyword to specify the existing web3 object.<br>The following config would attempt to use the existing web3 object and if unavailable attempt to connect to localhost:8545</p><p><code>config/contracts.json</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;development&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;dappConnection&quot;: [</span><br><span class="line">      &quot;$WEB3&quot;,</span><br><span class="line">      &quot;http://localhost:8545&quot;</span><br><span class="line">    ],</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Specify-node-to-deploy-to"><a href="#Specify-node-to-deploy-to" class="headerlink" title="Specify node to deploy to"></a>Specify node to deploy to</h2><p>Before Embark would assume this would be the same as the one configured in blockchain.json which could lead to some ackward configs for some devs, this has now been changed so you can specify it in the contracts config.</p><p><code>config/contracts.json</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;development&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;deployment&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="line">      &quot;port&quot;: 8545,</span><br><span class="line">      &quot;type&quot;: &quot;rpc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Specify-node-to-connect-whisper-to"><a href="#Specify-node-to-connect-whisper-to" class="headerlink" title="Specify node to connect whisper to"></a>Specify node to connect whisper to</h2><p><code>config/communication.json</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"default"</span>: &#123;</span><br><span class="line">    <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"provider"</span>: <span class="string">"whisper"</span>,</span><br><span class="line">    <span class="string">"available_providers"</span>: [<span class="string">"whisper"</span>, <span class="string">"orbit"</span>],</span><br><span class="line">    <span class="string">"connection"</span>: &#123;</span><br><span class="line">      <span class="string">"host"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">      <span class="string">"port"</span>: <span class="number">8546</span>,</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"ws"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Specify-url-to-get-assets"><a href="#Specify-url-to-get-assets" class="headerlink" title="Specify url to get assets"></a>Specify url to get assets</h2><p>You can specify for each environment what IPFS node to get the assets from</p><p><code>config/storage.json</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"development"</span>: &#123;</span><br><span class="line">      ....</span><br><span class="line">     <span class="string">"getUrl"</span>: <span class="string">"http://localhost:8080/ipfs/"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">  <span class="string">"livenet"</span>: &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="string">"getUrl"</span>: <span class="string">"https://gateway.ipfs.io/ipfs/"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugin-API-changes"><a href="#Plugin-API-changes" class="headerlink" title="Plugin API changes"></a>Plugin API changes</h3><p><img src="http://icons.iconarchive.com/icons/elegantthemes/beautiful-flat/128/plugin-icon.png" alt="plugin"></p><p>The following events are deprecated: abi-vanila, abi, abi-contracts-vanila, abi-vanila-deployment and have been renamed to code-vanila, code, code-contracts-vanila, code-vanila-deployment</p><p>plugins that use these events will get deprecation warnings, the deprecated events will be removed in 2.7.0</p><h3 id="New-Blockchain-options"><a href="#New-Blockchain-options" class="headerlink" title="New Blockchain options"></a>New Blockchain options</h3><p><img src="https://dappsforbeginners.files.wordpress.com/2015/02/ethereum-logo.jpg?w=200" alt="geth"></p><p>The following fields are now available at <code>config/blockchain.json</code> to enhance <code>embark blockchain</code>:</p><ul><li>“wsHost” - to specify the websocket host (default: localhost)</li><li>“wsPort” - to specify the websocket port (default: 8546)</li><li>“wsOrigins”- to specify the allowed origin of the websocket requests (default: FALSE), must be specified to something like <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> for the websocket connection to work.</li><li>“wsApi” - to specify the apis available through websockets (default: [‘eth’, ‘web3’, ‘net’, ‘shh’])</li></ul><h3 id="Misc-Bugfixes-and-Improvements"><a href="#Misc-Bugfixes-and-Improvements" class="headerlink" title="Misc Bugfixes and Improvements"></a>Misc Bugfixes and Improvements</h3><p><img src="http://i.imgur.com/L1r6Ac5.png" alt="bug fixes"></p><ul><li>tests no longer need the requires and initialization and can be run directly with embark. however you can still use these requires to run it yourself with mocha or your own preferred test framework</li><li>embark and mocha are no longer dependencies in the created dapp</li><li>you can specify a test file with <code>embark test &lt;filename&gt;</code></li><li>tests no longer need testrpc to be installed first</li><li><code>EmbarkJS.isNewWeb3()</code> to detect if web3 1.0 is available</li><li>demo app updated to use web3.js 1.0 and solc 0.4.17</li><li>warn user when websocket or http CORS is not set</li><li>tolerate solc compiler warnings, which could cause a crash sometimes</li></ul><h3 id="Thank-you"><a href="#Thank-you" class="headerlink" title="Thank you"></a>Thank you</h3><p>A big thanks to all that contributed to this release including <a href="https://github.com/toadkicker" target="_blank" rel="noopener">Todd Baur</a> and Jacob Beauchamp.</p><h3 id="Chatroom"><a href="#Chatroom" class="headerlink" title="Chatroom"></a>Chatroom</h3><p>To discuss about Embark or Dapp development, please <a href="https://gitter.im/iurimatias/embark-framework" target="_blank" rel="noopener">join us at the gitter channel</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;To-Update-to-2-6-0&quot;&gt;&lt;a href=&quot;#To-Update-to-2-6-0&quot; class=&quot;headerlink&quot; title=&quot;To Update to 2.6.0&quot;&gt;&lt;/a&gt;To Update to 2.6.0&lt;/h2&gt;&lt;p&gt;Embark
      
    
    </summary>
    
      <category term="announcements" scheme="https://embark.status.im/categories/announcements/"/>
    
    
  </entry>
  
  <entry>
    <title>Embark 2.5.0</title>
    <link href="https://embark.status.im/news/2017/06/28/embark-2-5-released/"/>
    <id>https://embark.status.im/news/2017/06/28/embark-2-5-released/</id>
    <published>2017-06-28T00:00:00.000Z</published>
    <updated>2019-05-07T08:18:52.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="To-Update-to-2-5-0"><a href="#To-Update-to-2-5-0" class="headerlink" title="To Update to 2.5.0"></a>To Update to 2.5.0</h2><p>Embark’s npm package has changed from <code>embark-framework</code> to <code>embark</code>, this sometimes can create conflicts. To update, first uninstall embark-framework 1 to avoid any conflicts with <code>npm uninstall -g embark-framework</code> followed by <code>npm install -g embark</code></p><p>to update from 2.4.2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g embark@2.5</span><br></pre></td></tr></table></figure><p>afterwards make sure <code>embark version</code> returns <code>2.5.0</code>.</p><h2 id="In-this-release"><a href="#In-this-release" class="headerlink" title="In this release"></a>In this release</h2><p>This release updates to the lastest dependencies, fixes a few things and has a lot of work under the hood necessary for future releases.</p><h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><ul><li>support for geth 1.6.5</li><li>updated to use web3.js 0.19.11</li><li>updated to use solc 0.4.11</li></ul><h2 id="Misc-Bugfixes-and-Improvements"><a href="#Misc-Bugfixes-and-Improvements" class="headerlink" title="Misc Bugfixes and Improvements"></a>Misc Bugfixes and Improvements</h2><ul><li><code>embark new</code> will now prompt for the dapp name if not specified as <code>embark new &lt;yourDappName&gt;</code></li><li>embark.js: <code>ContractName.new()</code> as been added as an alias for <code>ContractName.deploy()</code></li><li>embark.js: a method to easily send ether to a contract has been added: <code>ContractName.send(value, unit, options)</code> e.g <code>ContractName.send(2, &quot;ether&quot;, {from: web3.eth.accounts[1]})</code></li><li>orbit: Fix for orbit to make it work if the blockchain component is disabled</li><li>orbit: Use default config for orbit it none is specified in the config file</li><li>Demo app now has warning message for incompatible whisper versions</li><li>the JSON files of the contracts are now being outputted at dist/contracts/ (experimental)</li><li>whisper: Dashboard now displays the whisper version of the node</li><li>plugin API: extensions can now also be added as directories within the dapp directory</li><li>plugin API: plugins can now register a component to be displayed in the dashboard. e.g:</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">embark.registerServiceCheck(<span class="string">'PluginService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (someFunctionThatChecksTheService()) &#123;</span><br><span class="line">      cb(&#123;<span class="attr">name</span>: <span class="string">"MyServiceName"</span>, <span class="attr">status</span>: <span class="string">"on"</span>&#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cb(&#123;<span class="attr">name</span>: <span class="string">"MyServiceName"</span>, <span class="attr">status</span>: <span class="string">"off"</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Thank-you"><a href="#Thank-you" class="headerlink" title="Thank you"></a>Thank you</h2><p>A big thanks to all that contributed to this release including <a href="https://github.com/nathanph" target="_blank" rel="noopener">Nathan Hernandez</a>, <a href="https://github.com/atfornes" target="_blank" rel="noopener">Antonio Tenorio-Fornés</a>, <a href="https://github.com/jonjonsonjr" target="_blank" rel="noopener">Jon Johnson</a>, Andy Nogueira,  <a href="https://github.com/roo2" target="_blank" rel="noopener">roo2</a>, <a href="https://github.com/carlmon" target="_blank" rel="noopener">Carl Mönnig</a>, <a href="https://github.com/michaeljyeates" target="_blank" rel="noopener">Michael Yeates</a>, <a href="https://github.com/toadkicker" target="_blank" rel="noopener">Todd Baur</a>, <a href="https://github.com/imtypist" target="_blank" rel="noopener">黄俊钦</a>, <a href="https://github.com/RamiroMoreira" target="_blank" rel="noopener">Ramiro Moreira</a>, <a href="https://github.com/greggdourgarian" target="_blank" rel="noopener">gregg dourgarian</a></p><h2 id="Chatroom"><a href="#Chatroom" class="headerlink" title="Chatroom"></a>Chatroom</h2><p>To discuss about Embark or Dapp development, please <a href="https://gitter.im/iurimatias/embark-framework" target="_blank" rel="noopener">join us at the gitter channel</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;To-Update-to-2-5-0&quot;&gt;&lt;a href=&quot;#To-Update-to-2-5-0&quot; class=&quot;headerlink&quot; title=&quot;To Update to 2.5.0&quot;&gt;&lt;/a&gt;To Update to 2.5.0&lt;/h2&gt;&lt;p&gt;Embark
      
    
    </summary>
    
      <category term="announcements" scheme="https://embark.status.im/categories/announcements/"/>
    
    
  </entry>
  
</feed>
